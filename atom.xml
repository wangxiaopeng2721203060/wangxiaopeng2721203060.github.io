<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老渔夫爱吃锅包肉</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-26T01:58:33.060Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>王小朋</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker存储</title>
    <link href="http://yoursite.com/2096/09/26/docker%E5%AD%98%E5%82%A8/"/>
    <id>http://yoursite.com/2096/09/26/docker存储/</id>
    <published>2096-09-25T16:00:00.000Z</published>
    <updated>2019-12-26T01:58:33.060Z</updated>
    
    <content type="html"><![CDATA[<p>#Docker 存储</p><h3 id="Docek-镜像层的镜像分层结构"><a href="#Docek-镜像层的镜像分层结构" class="headerlink" title="Docek 镜像层的镜像分层结构"></a>Docek 镜像层的镜像分层结构</h3><a id="more"></a><ul><li>docker的镜像分层结构，如下所示：</li></ul><p><img src="https://docs.docker.com/storage/storagedriver/images/container-layers.jpg" alt="基于Ubuntu映像的容器层"></p><ul><li><p>docker镜像中引入层layer概念，镜像的制作过程中的每一步都会生产一个新的镜像层</p></li><li><p>容器读写层的工作原理</p><blockquote><p>我们刚刚在说镜像的分层特性的时候说到镜像是只读的。而事实上当我们使用镜像启动一个容器的时候，我们其实是可以在容器里随意读写的，从结果上看，似乎与镜像的只读特性相悖。</p><p>我们继续看上面的图，其实可以看到在镜像的最上层，还有一个读写层。而这个读写层，即在容器启动时为当前容器单独挂载。每一个容器在运行时，都会基于当前镜像在其最上层挂载一个读写层。而用户针对容器的所有操作都在读写层中完成。一旦容器销毁，这个读写层也随之销毁。</p><blockquote><p>知识点： 容器=镜像+读写层</p></blockquote><p>而我们针对这个读写层的操作，主要基于两种方式：写时复制和用时分配。</p></blockquote></li></ul><hr><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p><img src="https://docs.docker.com/storage/storagedriver/images/sharing-layers.jpg" alt="容器共享相同的图像"></p><ul><li><p>容器由最上面一个可写的容器层和若干个只读的镜像层组成，容器的数据就存在这些层中。这种分层结构最大的特点是Copy-on-Write。</p><ol><li><p>新数据会直接存放在最上面的容器层</p></li><li><p>修改现有数据会从镜像层复制文件到容器中，再在容器层修改并保存，镜像层的数据不会发生改变</p></li><li><p>若多个层中有命名相同的文件，用户只能看到最上面一层的文件</p></li></ol></li></ul><ul><li>分层结构使镜像和容器的创建、共享以及分发变得非常高效，而这些都要归功于 Docerk stoage driver。<strong>正是 storage driver 实现了多层数据的堆叠并为用户提供一个单一的合并之后的统一视图</strong>。</li></ul><hr><h3 id="Docker-为容器提供了两种存放数据的资源："><a href="#Docker-为容器提供了两种存放数据的资源：" class="headerlink" title="Docker 为容器提供了两种存放数据的资源："></a>Docker 为容器提供了两种存放数据的资源：</h3><ul><li>由storage driver（存储驱动） 管理的镜像层和容器层<ul><li>用来放一些无状态的数据<ul><li><strong>对于某些容器，直接将数据放在由</strong> storage driver <strong>维护的层中是很好的选择，比如那些无状态的应用。无状态意味着容器没有需要持久化的数据，随时可以从镜像直接创建。即存在与否依赖镜像的存在。</strong></li></ul></li></ul></li><li>Data Volume。（数据卷）<ul><li>用来放一些有状态的数据，例如数据库<ul><li><strong>本质上是</strong> Docker Host （主机）<strong>文件系统中的目录或文件，能够直接被 ** mount （挂载）</strong>到容器的文件系统中**。</li></ul></li></ul></li></ul><h4 id="关于docker镜像的三问"><a href="#关于docker镜像的三问" class="headerlink" title="关于docker镜像的三问"></a>关于docker镜像的三问</h4><ul><li>基于镜像A创建镜像B时是否会拷贝A镜像中的所有文件：<code>是不会的</code></li><li>基于镜像创建容器时是否会拷贝镜像中的所有文件至文件层：<code>不会的</code></li><li>容器与镜像在结构上有什么区别：<code>没有区别容器会比镜像多了一个</code> <code>merged</code>文件</li></ul><blockquote><p>在讲原理前，先讲下写时复制和写时分配</p></blockquote><h4 id="写时复制（CoW）"><a href="#写时复制（CoW）" class="headerlink" title="写时复制（CoW）"></a>写时复制（CoW）</h4><blockquote><p>所有驱动都用到的技术——写时复制（CoW）。CoW就是copy-on-write，表示只在需要写时才去复制，这个是针对已有文件的修改场景比如基于一个image启动多个Container，如果为每个Container都去分配一个image一样的文件系统，那么将会占用大量的磁盘空间。而CoW技术可以让所有的容器共享image的文件系统，所有数据都从image中读取，只有当要对文件进行写操作时，才从image里把要写的文件复制到自己的文件系统进行修改。所以无论多少个容器共享同一个image，所作的写操作都是从image中复制到自己的文件系统中的复制本上进行，并不会修改image的源文件，且多个容器操作同一个文件，会在每个容器的文件系统里生成一个复本，每个容器修改的都是自己的复本，相互隔离的，相互不影响。使用CoW可以有效的提高磁盘的利用率。</p></blockquote><h4 id="用时分配（allocate-on-demand）"><a href="#用时分配（allocate-on-demand）" class="headerlink" title="用时分配（allocate-on-demand）"></a>用时分配（allocate-on-demand）</h4><blockquote><p>而用时分配是用在原本没有这个文件的场景，只有在要新写入一个文件时才分配空间，这样可以提高存储资源的利用率。比如启动一个容器，并不会为这个容器预分配一些磁盘空间，而是当有新文件写入时，才按需分配新空间。</p></blockquote><h4 id="Docker存储驱动的作用"><a href="#Docker存储驱动的作用" class="headerlink" title="Docker存储驱动的作用"></a>Docker存储驱动的作用</h4><blockquote><p>将这些分层的镜像文件堆叠起来，并且提供统一的视图.使container的文件系统看上去和我们普通的文件系统没什么区别。<br>当创建一个新的容器的时候,实际上是在镜像的分层上新添加了一层container layer（容器层）.之后所有对容器产生的修改,实际都只影响这一层。</p><p>注意</p><p>容器层：读写层(可写层)<br>镜像层：只读层</p></blockquote><blockquote><p> Docker 支持多种 storage driver，有 AUFS 、Device Mapper 、Btrfs 、OverlayFS 、VFS 和ZFS。它们都能实现分层的架构，同时又有各自的特性。对于Docker 用户来说，具体选择使用哪个 storage driver 是一个难题，因为：</p></blockquote><p>​            没有哪个driver 能够适应所有的场景。</p><p>​            driver 本身在快速发展和迭代。</p><blockquote><p>优先使用 Linux 发行版默认的 storage driver。Docker 安装时会根据当前系统的配置选择默认的 driver。默认 driver 具有最好的稳定性，因为默认 driver 在发行版上经过了严格的测试。</p></blockquote><blockquote><p>运行<code>docker info</code>可以查看可查看当前系统使用的<code>Storage driver</code>。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; [root@izbp1dg6m4eebtcm77n0smz ~]# docker info</span><br><span class="line">&gt; &gt; Client:</span><br><span class="line">&gt; &gt; Debug Mode: false</span><br><span class="line">&gt; &gt; </span><br><span class="line">&gt; &gt; Server:</span><br><span class="line">&gt; &gt; Containers: 6</span><br><span class="line">&gt; &gt; Running: 4</span><br><span class="line">&gt; &gt; Paused: 0</span><br><span class="line">&gt; &gt; Stopped: 2</span><br><span class="line">&gt; &gt; Images: 4</span><br><span class="line">&gt; &gt; Server Version: 19.03.5</span><br><span class="line">&gt; &gt; Storage Driver: overlay2</span><br><span class="line">&gt; &gt; Backing Filesystem: extfs</span><br><span class="line">&gt; &gt; Supports d_type: true</span><br><span class="line">&gt; &gt; Native Overlay Diff: false</span><br><span class="line">&gt; &gt; Logging Driver: json-file</span><br><span class="line">&gt; &gt; Cgroup Driver: cgroupfs</span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote></blockquote><hr><blockquote><p>Ubuntu 用的 <code>AUFS</code>，底层文件系统是 <code>extfs</code>，各层数据存放在 <code>/var/lib/docker/aufs</code>。<br>centos默认的<code>driver</code>用的是<code>overlay2</code>，底层的文件系统是xfs,各层数据存放在<code>/var/lib/docker</code></p></blockquote><blockquote><p>而写时分配是用在原本没有这个文件的场景，只有在要新写入一个文件时才分配空间，这样可以提高存储资源的利用率。</p><p>比如启动一个容器，并不是为这个容器预分配一些磁盘空间，而是当有新文件写入时，才按需分配新空间。</p></blockquote><ul><li>docker提供了多种的存储驱动来实现不同的方式存储镜像</li></ul><h5 id="Docker五种存储驱动原理及应用场景和性能测试对比"><a href="#Docker五种存储驱动原理及应用场景和性能测试对比" class="headerlink" title="Docker五种存储驱动原理及应用场景和性能测试对比"></a>Docker五种存储驱动原理及应用场景和性能测试对比</h5><blockquote><p><code>Docker</code> 最开始采用AUFS作为文件系统，也得益于AUFS分层的概念，实现了多个Container可以共享同一个image。但由于<code>AUFS</code> 为并入 <code>Linux</code>内核，且只支持 <code>Ubuntu</code>，考虑到兼容的问题，在 <code>Docker 0.7</code> 版本中引入了存储驱动，就如Docker官网上说的，没有单一的驱动适应所有的应用场景，要根据不同的场景选择合适的存储驱动，才能有效的提高Docker 的性能。如何选择适合的存储驱动，要先了解存储驱动原理才能更好的判断。</p></blockquote><blockquote><p>接下来我们说说这些分层的镜像是如何在磁盘中存储的。</p></blockquote><ul><li><p><code>docker</code> 提供了多种存储驱动来实现不同的方式存储镜像</p><ul><li><p>下列出了 <code>Docker</code> 中支持的存储驱动程序：</p><table><thead><tr><th align="center">技术</th><th align="center">存储驱动成名称</th></tr></thead><tbody><tr><td align="center"><code>OverlayFS</code></td><td align="center"><code>overlay</code> 或  <code>overlay2</code></td></tr><tr><td align="center"><code>AUFS</code></td><td align="center"><code>aufs</code></td></tr><tr><td align="center"><code>Btrfs</code></td><td align="center"><code>btrfs</code></td></tr><tr><td align="center"><code>Device Mapper</code></td><td align="center"><code>devicemapper</code></td></tr><tr><td align="center"><code>VFS</code></td><td align="center"><code>vfs</code></td></tr><tr><td align="center"><code>ZFS</code></td><td align="center"><code>zfs</code></td></tr></tbody></table></li></ul></li></ul><h5 id="AUFS"><a href="#AUFS" class="headerlink" title="AUFS"></a>AUFS</h5><blockquote><p>AUFS（AnotherUnionFS）是一种 Union FS ，是文件级的存储驱动。AUFS 是一个能透明覆盖一个或多个县有文件系统的层状文件系统，把多层合并成文件系统的单层表示。简单来说就是支持将不同目录挂载到同一个虚拟文件系统下的文件系统。这种文件可以一层一层地叠加修改文件。无论低下有多少层都是只读的，只有最上层的文件系统是可写的。当需要修改文件时，AUFS创建该文件的一个副本，使用CoW将文件从只读层复制到可写层进行修改，结果保存在可写层。在Docker中，低下的只读层就是image，可写层就是Container。结构如下图所示：</p></blockquote><p>  <a href="http://dockone.io/uploads/article/20190702/87af417e9f80a3eb8ae9716ae07b3dc1.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/87af417e9f80a3eb8ae9716ae07b3dc1.jpg" alt="1.jpg"></a></p><blockquote><p><strong>历史</strong>：aufs驱动老早就在Docker中存在了！其实，他在使用<code>graphdriver</code>这个名字之前久存在了。如果你查看项目在那（即首次使用graphdriver名称）提交之前的历史，之前项目中当时只有一个aufs的实现。下边devicemapper部分会讲到更多关于graphdriver这个名称诞生的历史。</p><p><strong>实现</strong>：Aufs最初代表的意思“另一个联合文件系统（another union filesystem）”，试图对当时已经存在的UnionFS实现进行重写。正如你期望的那样，它是一个传统意义的上层覆盖，通过利用aufs称作为“分支（branch）”的特性，让堆叠的目录合并成一个堆叠内容单一挂载点视图。此驱动会将父级信息组合一个有序列表，并把它作为挂载参数，然后把重活移交给aufs来把这些分层组装成一个联合视图。更多的细节信息可以在aufs的<a href="http://aufs.sourceforge.net/aufs3/man.html" target="_blank" rel="noopener">帮助文档</a>上看到。</p><p><strong>优点</strong>：这可能是历史最久且测试最完善的graphdriver后端了。它拥有不错的性能，也比较稳定，适用于广泛的场景。尽管它只在Ubuntu或者Debian的内核上才可以启用（下边有说明），但是这两个发行版和Docker一起使用的场景已经非常多，这让它在广阔的环境中得到了验证。同时，通过让不同的容器从同一个分层里面加载相同的库（因为他们在磁盘上是相同的inode）达到了共享内存页的效果。</p><p><strong>缺点</strong>：Aufs从来没有被上游Linux内核社区接受。多年来Ubuntu和Debian都需要往内核集成一个历史久远的补丁包，且原作者已经放弃了让它被内核采纳的努力。可能与IPV4和IPv6的辩论有些类似，人们担心某一天内核更新后会出现难以整合aufs的补丁的情况，从而导致aufs没得玩。但是就如IPv6，替换aufs势在必行的决心讲了一年又一年。除此之外，它面临着很多其他比较棘手的问题。其中一个最麻烦的、也是比较有历史的问题（尽管某种程度上这是一个安全的特性），是关于在高层更改向上拷贝的文件的权限的，这个问题困扰了不少用户。最终在2015年早期的时候通过编号为<a href="http://dockone.io/docker/docker#11799" target="_blank" rel="noopener">#11799</a>的PR使用aufs的<code>dirperm1</code>特性修复了。自然，这需要内核中有具有<code>dirperm1</code>能力aufs，然而这在今天任何较新版本的Ubuntu或者Debian上都已经不成问题了。</p><p><strong>总结</strong>：如果你在使用Ubtuntu或者Debian，那默认的graphdriver就是aufs，它能满足你绝大多数需求。有人期望有一天它能被overlay的实现取代，但是考虑到overlay文件系统的诸多问题，以及在上游内核中的成熟程度等挑战，这尚未实现。最后，aufs中没有配额的支持。</p></blockquote><h5 id="Overlay"><a href="#Overlay" class="headerlink" title="Overlay"></a>Overlay</h5><blockquote><p>Overlay 是Linux内核3.18后支持的，也是一种Union FS，和AUFS的多层不同的是Overlay只有两层：一个upper文件系统和一个lower文件系统，分别代表Docekr的镜像层和容器层。当需要修改一个文件时，使用CoW将文件从只读的lower复制到可写的upper进行修改，结果也保存在upper层。在Docekr中，底下的只读层就是image，可写层就是Container。目前最新的OverlayFS为Overlay2。结构图如下所示：</p></blockquote><p>  <a href="http://dockone.io/uploads/article/20190702/c12e244abea02f7ed1eb42f0ccdbcf1d.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/c12e244abea02f7ed1eb42f0ccdbcf1d.jpg" alt="2.jpg"></a></p><blockquote><p><strong>历史</strong>：<strong>2014年8月</strong>，Red Hat的 Alex Larsson在编号为<a href="https://github.com/docker/docker/commit/453552c8384929d8ae04dcf1c6954435c0111da0" target="_blank" rel="noopener">453552c8384929d8ae04dcf1c6954435c0111da0</a>的代码提交中添加了针对OverlayFS（最初的上游内核的名称）的graphdriver。</p><p><strong>实现</strong>：Overlay是一个联合文件系统，它的概念较之aufs的分支模型更为简单。Overlay通过三个概念来实现它的文件系统：一个“下层目录（lower-dir）”，一个“上层目录（upper-dir）”，和一个做为文件系统合并视图的“合并（merged）”目录。受限于只有一个“下层目录”，需要额外的工作来让“下层目录”递归嵌套（下层目录自己又是另外一个overlay的联合），或者按照Docker的实现，将所有位于下层的内容都硬链接到“下层目录”中。正是这种可能潜在的inode爆炸式增长（因为有大量的分层和硬连接）阻碍了很多人采用Overlay。Overlay2通过利用更高内核（4.0以及以上的版本）中提供了的更优雅处理多个位于下层分层的机制解决了这个问题。</p><p><strong>优点</strong>：Overlay作为一个合并进主线Linux内核的一个有完整支持的联合文件系统有望成为人们的焦点。与aufs类似，通过使用磁盘上相同的共享库，它也能让分散的容器实现内存共享。Overlay同时有很多的上游Linux内核基于现代的应用场景，如Docker，被持续开发（参看overlay2）。</p><p><strong>缺点</strong>：硬链接的实现方式已经引发了 <a href="http://dockone.io/docker/docker#10613" target="_blank" rel="noopener">inode耗尽</a>的问题，这阻碍了它的大规模采用。inode耗尽并不是唯一的问题，还有其他一些与用户命名空间、SELinux支持有关的问题，且整体的成熟状况不足也阻碍着overlay直接取代aufs成为Docker默认的graphdriver。随着很多问题的解决，特别是在最新的内核发新版中，overlay的可用度越来越高了。如今出现的Overlay2修复了inode耗尽的问题，应该是从Docker 1.12版本之后的焦点，成为overlay驱动的后续开发对象。出于向后兼容的原因，<code>overlay</code>驱动将会继续留在Docker引擎中继续支持现有的用户。</p><p><strong>总结</strong>：考虑到aufs没有足够多的发行版的支持，能有一个上游集成的联合文件系统且拥有Linux内核文件系统社区的支持，overlay驱动的加入是一个重大进步。Overlay在过去的18-24个月已经成熟了很多，并且随着overlay2的出现，它之前一些麻烦的问题已经解决了。希望overlay（或者更具可能性的overlay2）会成为未来默认的graphdriver。为了overlay最好的体验，上游内核社区在4.4.x的内核系列里面修复了很多overlay实现中存在的问题；选择该系列中更新的版本可以获得overlay更好的性能和稳定性。</p></blockquote><h5 id="Overlay2"><a href="#Overlay2" class="headerlink" title="Overlay2"></a>Overlay2</h5><blockquote><p><strong>历史</strong>：<a href="https://github.com/dmcgowan" target="_blank" rel="noopener">Derek McGowan</a>在编号为<a href="https://github.com/docker/docker/pull/22126" target="_blank" rel="noopener">#22126</a>的PR中添加了overlay2的graphdriver，在<strong>2016年6月</strong>被合并进Docker 1.12版本，正如该PR的标题注明的，要取代之前overlay的主要原因是它能“支持多个下层目录”，能解决原先驱动中inode耗尽的问题。</p><p><strong>实现</strong>：在上面的overlay部分已经讲述了Linux内核中的Overlay的框架。上面链接的PR中改进了原有的设计，基于Linux内核4.0和以后版本中overlay的特性，可以允许有多个下层的目录。</p><p><strong>优点</strong>：overlay2解决了一些因为最初驱动的设计而引发的inode耗尽和一些其他问题。Overlay2继续保留overlay已有的优点，包括在同一个引擎的多个容器间从同一个分层中加载内库从而达到内存共享。</p><p><strong>缺点</strong>：现在可能唯一能挑出overlay2的问题是代码库还比较年轻。很多早期的问题已经在早期测试过程中发现并被及时解决了。但是Docker 1.12是第一个提供overlay2的发行版本，随着使用量的增长，相信可能还会发现其他问题。</p><p><strong>总结</strong>：将Linux内核中的一个现代的、广受支持的联合文件系统，和一个和Docker中一个性能优秀的graphdriver结合起来，这应该是Docker引擎未来打造默认的graphdriver最好的道路，只有这样才能获得各种Linux发行版广泛的支持。</p></blockquote><h5 id="Device-mapper"><a href="#Device-mapper" class="headerlink" title="Device mapper"></a>Device mapper</h5><blockquote><p>Device mapper 是Linux 内核 2.6.9 后支持的，提供的一种从逻辑设备到物理设备的映射框架机制，在该机制下，用户可以很方便的根据自己的需要制定实现存储资源的管理策略。前面讲的 AUFS 和 OverlayFS 都是文件级存储，而 Device mapper 是块级存储，所有的操作都是直接对块进行操作，而不是文件。Device mapper 驱动会先在块设备上创建一个资源池，然后在资源池上创建一个带有文件系统的基本设备，所有镜像都是这个基本设备的快照，而容器则是镜像的快照。所以在容器里看到文件系统是资源池上基本设备的文件系统的快照，并不有为容器分配空间。当要写入一个新文件时，在容器的镜像内为其分配新的块并写入数据，这个用时分配。当要修改已有文件时，再使用 CoW 为容器快照分配块空间，将要修改的数据复制在容器快照中新的块里在进行修改。Device mapper 驱动默认会创建一个 100 G 的文件包含镜像和容器。每个容器被限制在 10G 大小的卷内，可以自己设置调整。结构如下图所示：</p></blockquote><p>  <a href="http://dockone.io/uploads/article/20190702/0ef920a30190955999076f524229f321.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/0ef920a30190955999076f524229f321.jpg" alt="3.jpg"></a></p><blockquote><p> <strong>历史</strong>：Devicemapper很早就以Ｃ代码的包装器面貌存在了，用来和libdevmapper进行交互； 是2013的９月Alex Larsson在编号为<a href="https://github.com/docker/docker/commit/739af0a17f6a5a9956bbc9fd1e81e4d40bff8167" target="_blank" rel="noopener"> 739af0a17f6a5a9956bbc9fd1e81e4d40bff8167</a>的代码提交中添加的。几个月后的重构了才诞生了我们现在所知道的“graphdriver”这个词；Solomon Hykes在2013年10月份早期代码合并的注释中说：将devmapper和aufs整合进通用的“graphdriver”框架。</p><p>  <strong>实现</strong>：devicemapper这个graphdriver利用了Linux中devicemapper代码中众多特性之一，“轻配置（thin provisioning）”，或者简称为“thinp”。<em>（译注：根据Wikipedia，“thin provisioning是利用虚拟化技术，让人觉得有比实际可用更多的物理资源。如果系统的资源足够，能同时满足所有的虚拟化的资源，那就不能叫做thin-provisioned。”）</em> 这与之前提到的联合文件系统不同，因为devicemapper是基于块设备的。这些“轻配置（thin-provisioned）”的块设备带来的是如联合文件系统所提供的一样轻量的行为，但是最重要的一点是，他们不是基于文件的（而是基于块设备的）。正如你能推测的，这让计算分层之间的差别变得不再容易，也丧失了通过在容器间使用同样的库片段而共享内存的能力。</p><p>  <strong>优点</strong>：Devicemapper在过去的年间也被一些人感到不屑，但是它提供的一个非常重要的能力让红帽系（Fedora,RHEL，Project Atomic）也有了一个graphdriver。因为它是基于块设备而不是基于文件的，它有一些内置的能力如配额支持，而这在其他的实现中是不容易达到的。</p><p>  <strong>缺点</strong>：使用devicemapper没有办法达到开箱立即唾手可得很好的性能。你必须遵循<a href="https://docs.docker.com/engine/userguide/storagedriver/device-mapper-driver/#/configure-direct-lvm-mode-for-production" target="_blank" rel="noopener">安装和配置指示</a>才能得到性能还可以的配置。并且最重要的是，在任何需要用Docke引擎来做点正事的地方，都不要使用“虚拟设备（loopback）”模式（对于运行有devicemapper且负载高的系统，如延迟删除（ deferred removal）这样的特性绝对有必要的，这能减少引擎看起来好似夯住了一样的悲剧。）。它的一些特性依赖libdevmaper特定的版本，并且需要比较高级的技能来验证系统上所有的设置。同时，如果Docker Engine的二进制是静态编译的话，devicemapper会完全无法工作，因为它需要<a href="http://dockone.io/docker/docker#11412" target="_blank" rel="noopener">udev sync</a>的支持，而这不能被静态编译进引擎中。</p><p>  <strong>总结</strong>：对于红帽类发行版本来说，devicemapper已经成为“可以直接用”的选择，并且在过去几年间里得到了红帽团队的大力支持和改进。它质量上有优点也有缺点，如果安装/配置过程中没有特别格外注意的话，可能导致和其他选项比较起来性能低下、质量不高。鉴于overlay和overlay2受到了Fedora和RHEL最新的内核的支持，并且拥有SELinux的支持，除非在Red Hat场景中有某种必须使用devicemapper的需求，我想随着用户的成熟他们会转向overlay的怀抱。</p></blockquote><h5 id="Btrfs"><a href="#Btrfs" class="headerlink" title="Btrfs"></a>Btrfs</h5><blockquote><p>Btrfs 被称为下一代写时复制文件系统，并入Linux内核，也是文件级存储，但可以向 Device mapper 一直操作底层设备。 Btrfs 把文件系统的一部分配置为一个完整的子文件系统，称为 subvolume。那么采用 subvolume ，一个大的文件系统可以被划分为很多个子文件系统，这些子文件系统共享底层的设备空间，在需要磁盘空间使用时便从底层设备中分配，类似应用程序调用 malloc（）分配内存一样。为了灵活利用设备空间， Btrfs 将磁盘空间划分为多个 chunk。每个 chunk 可以使用不同的磁盘空间分配策略。比如某些 chunk 只存放 metadata ，某些chunk 只存放数据。这种模型有很多优点，比如 Btrfs 支持动态添加设备。用户在系统中添加新的磁盘之后，可以使用 Btrfs 的命令将该设备添加到文件系统中。Btrfs 把一个大的文件系统当成一个资源池，配置成多个完整的子文件系统，还可以往资源池里加新的子文件系统，而基础镜像则是子文件系统的快照，每个子镜像和容器都有自己的快照，这些快照都是 subvolume 的快照。</p></blockquote><p>   <a href="http://dockone.io/uploads/article/20190702/99ab3acda52806a948625219d9e96a0b.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/99ab3acda52806a948625219d9e96a0b.jpg" alt="4.jpg"></a></p><blockquote><p>当写入一个新文件时，为在容器的快照里为其分配一个新的数据块，文件写在这个空间里，这个叫做分配。而当要修改已有文件时，使用 CoW 复制分配一个新的原始数据和快照，在这个新分配的空间变更数据，变结束再跟新相关的数据结构指向新子文件系统和快照，原来的原始数据和快照没有指针指向，被覆盖。</p></blockquote><blockquote><p><strong>历史</strong>：<strong>2013年12月</strong>较晚的时候，Red Hat公司的Alex Larsson在编号为<a href="https://github.com/docker/docker/commit/e51af36a85126aca6bf6da5291eaf960fd82aa56" target="_blank" rel="noopener">e51af36a85126aca6bf6da5291eaf960fd82aa56</a>的提交中，让使用btrfs作为管理<code>/var/lib/docker</code>的文件系统成为可能。</p><p><strong>实现</strong>：Btrfs的原生特性中，有两个是“子卷（subvolumes）”和“快照（snapshots）”。<em>（译注：根据Wikipedia，“子卷在btrfs中不是一个块设备，也不应该被当做是一个块设备。相反，子卷可以被想象成POSIX文件的命名空间。这个命名空间可以通过顶层的子卷来访问到，也可以独立地被挂载。快照在Btrfs中实际上是一个子卷，通过使用Btrfs的写时复制来和其他的子卷共享数据，对快照的更改不会影响原先的子卷。” ）</em> graphdriver实现中主要结合了这两个能力，从而提供了堆叠和类似写时复制的特性。当然，graphdriver的根（默认情况下是：<code>/var/lib/docker</code>）需要是一个被btrfs文件系统格式化的磁盘。</p><p><strong>优点</strong>：Btrfs几年前发布的时候（2007-2009时代），它被视作一个未来的Linux文件系统并<a href="https://lwn.net/Articles/342892/" target="_blank" rel="noopener">受到了大量的关注</a>。如今在上游Linux内核中，该文件系统已经比较健壮，并受到良好的支持，是众多可选的文件系统之一。</p><p><strong>缺点</strong>：但是Btrfs并没有成为Linux发行版的主流选择，所以你不大可能已经有一个btrfs格式化的磁盘。因为这种在Linux发行版中采用不足的原因，它并没有受到类似其他graphdriver一样的关注和采用。</p><p><strong>总结</strong>：如果你正在使用btrfs，那很显然的这个graphdriver应该迎合了你的需求。在过去几年有过很多Bug，并且有一段时间缺乏对SELinux的支持，但是这已经<a href="http://dockone.io/docker/docker#16452" target="_blank" rel="noopener">被修复</a>了。同时，对btrfs配额的支持也直接加进了docker守护进程中，这是<a href="https://github.com/zhuguihua" target="_blank" rel="noopener">Zhu Guihua</a>在编号为<a href="http://dockone.io/docker/docker#19651" target="_blank" rel="noopener">#19651</a>的PR中添加的，这个特性包含在了Docker 1.12版本中。</p></blockquote><h5 id="ZFS"><a href="#ZFS" class="headerlink" title="ZFS"></a>ZFS</h5><blockquote><p>ZFS 文件系统是一个革命性的全新的文件系统，它从根本上改变了文件系统的管理方式， ZFS 完全抛弃了 “ 卷管理 ” ，不再创建虚拟的卷，而是把所有设备集中到一个存储池中进行管理，用 “ 存储池 ”  的概念来管理物理存储空间。过去，文件系统都是构建在物理设备之上的，为了管理这些物理设备，并为数据提供冗余，“ 卷管理 ” 的概念提供了一个单设备的映射。而 ZFS 创建在虚拟的，被称为 “ zpools ” 的存储池之上。每个存储池由若干虚拟设备（ virtual devices ，vdevs ）组成。这些虚拟设备可以是原始磁盘，也节能是一个RAID1 镜像设备，或是非标准 RAID 等级的多磁盘组。  于是 zpool 上的文件系统可以使用这些虚拟设备的总存储容量。</p></blockquote><p>  <a href="http://dockone.io/uploads/article/20190702/d6daba2b7adfe96daca62f9ed90bf0c4.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/d6daba2b7adfe96daca62f9ed90bf0c4.jpg" alt="5.jpg"></a></p><blockquote><p>下面看一下Docker 里ZFS的使用。首先从 zpool里分配一个ZFS 文件系统给镜像的基础层，而其他镜像层则是这个 ZFS 文件系统快照的克隆，快照是只读的，而克隆是可写的，当容器启动时则在镜像的顶层生成一个可写层。如下图所示：</p></blockquote><p>  <a href="http://dockone.io/uploads/article/20190702/34cc4c9ea6c96b6f83dabb961ed8950e.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/34cc4c9ea6c96b6f83dabb961ed8950e.jpg" alt="6.jpg"></a></p><blockquote><p>d当要写一个新文件时，使用按需分配，一个新的数据块从 zpool 里生成新的数据写入这个块，而这个新空间存于容器（ ZFS 的克隆 ）里。</p><p>当要修改一个已存在的文件时，使用写时复制，分配一个新空间并把原始数据复制到新空间完成修改。</p></blockquote><blockquote><p><strong>历史</strong>：ZFS的graphdriver是由Arthur Gautier和Jörg Thalheim一起在<a href="http://dockone.io/docker/docker#9411" target="_blank" rel="noopener">#9411</a>的PR中实现的，在<strong>2014年的5月</strong>被合并进了Docker引擎里面，并且从Docker 1.7版本开始用户可以使用。该实现依赖Go的一个三方包<a href="https://github.com/mistifyio/go-zfs" target="_blank" rel="noopener">go-zfs</a>进行相关zfs命令的交互。</p><p><strong>实现</strong>：与btrfs和devicemapper类似，要使用zfs驱动必需要有一个ZFS格式化的块设备挂载到graphdriver路径（默认是/var/lib/docker）。同时也需要安装好zfs工具（在绝大多数的发行版上是一个名为zfs-utils的包）供zfs Go库调用来执行相关操作。ZFS有能力创建快照（与btrfs类似），然后以快照的克隆作为分享层的途径（在ZFS的实现中成了一个快照）。因为ZFS不是一个基于文件的实现，aufs和overlay中所拥有的内存共享能力在ZFS是没有的。</p><p><strong>优点</strong>：ZFS正在受到越来越多的欢迎，在Ubuntu 16.04中，在Ubuntu的LXC/LXD中已经被使用。最初由Sun创建，ZFS已经存在很长的时间了，并且在Solaris和很多BSD的衍生版中使用，并且它的Linux移植版实现看起来也比较稳定，对于容器文件系统的场景也有足够合理性能。<code>ZFS</code>graphdriver也很及时的在Dockr 1.12中通过PR <a href="http://dockone.io/docker/docker#21946" target="_blank" rel="noopener">#21946</a>添加了配额的支持，这让它在配额支持方面和btrfs、devicemapper站在了同一起跑线上。</p><p><strong>缺点</strong>：除了没有基于文件（inode）的共享达到内库共享之外，很难说ZFS和其它同样基于块设备的实现相比有什么缺点。通过比较，ZFS看起来欢迎程度越来越高。对于那些完全支持或者正在使用ZFS的Linux发行版或者UNIX衍生版而言，zfs graphdriver可以是一个非常好的选择。</p><p><strong>总结</strong>：ZFS的支持为Docker引擎中稳定的graphdriver加了分。对于那些ZFS的使用者，或者那些ZFS扮演了更要角色的发行版来说，Docker能直接支持该文件系统，对这些社区来说是一个好消息。对于那些默认文件系统是ext4和xfs的发行版，默认采用overlay驱动的用户来说，时间会告诉我们他们是否会对zfs驱动产生更多的兴趣。</p></blockquote><h4 id="存储驱动的对比及适应场景"><a href="#存储驱动的对比及适应场景" class="headerlink" title="存储驱动的对比及适应场景"></a>存储驱动的对比及适应场景</h4><table><thead><tr><th><strong>存储驱动</strong></th><th><strong>特点</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td>AUFS</td><td>联合文件系统、未并入内核主线、文件级存储</td><td>作为docker的第一个存储驱动，已经有很长的历史，比较稳定，且在大量的生产中实践过，有较强的社区支持</td><td>有多层，在做写时复制操作时，如果文件比较大且存在比较低的层，可能会慢一些</td><td>大并发但少IO的场景</td></tr><tr><td>overlayFS</td><td>联合文件系统、并入内核主线、文件级存储</td><td>只有两层</td><td>不管修改的内容大小都会复制整个文件，对大文件进行修改显示要比小文件消耗更多的时间</td><td>大并发但少IO的场景</td></tr><tr><td>Devicemapper</td><td>并入内核主线、块级存储</td><td>块级无论是大文件还是小文件都只复制需要修改的块，并不是整个文件</td><td>不支持共享存储，当有多个容器读同一个文件时，需要生成多个复本，在很多容器启停的情况下可能会导致磁盘溢出</td><td>适合io密集的场景</td></tr><tr><td>Btrfs</td><td>并入linux内核、文件级存储</td><td>可以像devicemapper一样直接操作底层设备，支持动态添加设备</td><td>不支持共享存储，当有多个容器读同一个文件时，需要生成多个复本</td><td>不适合在高密度容器的paas平台上使用</td></tr><tr><td>ZFS</td><td>把所有设备集中到一个存储池中来进行管理</td><td>支持多个容器共享一个缓存块，适合内存大的环境</td><td>COW使用碎片化问题更加严重，文件在硬盘上的物理地址会变的不再连续，顺序读会变的性能比较差</td><td>适合paas和高密度的场景</td></tr></tbody></table><p><a href="http://dockone.io/uploads/article/20190702/747be895d53add6ea9ddf868f95ff8ec.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/747be895d53add6ea9ddf868f95ff8ec.jpg" alt="7.jpg"></a></p><h5 id="AUFS-VS-Overlay"><a href="#AUFS-VS-Overlay" class="headerlink" title="AUFS VS  Overlay"></a>AUFS VS  Overlay</h5><blockquote><p>AUFS和Overlay都是联合文件系统，但AUFS有多层，而Overlay只有两层，所以在做写时复制操作时，如果文件比较大且存在比较低的层，则AUSF可能会慢一些。而且Overlay并入了linux kernel mainline，AUFS没有，所以可能会比AUFS快。但Overlay还太年轻，要谨慎在生产使用。而AUFS做为docker的第一个存储驱动，已经有很长的历史，比较的稳定，且在大量的生产中实践过，有较强的社区支持。目前开源的DC/OS指定使用Overlay。</p></blockquote><h5 id="Overlay-VS-Device-mapper"><a href="#Overlay-VS-Device-mapper" class="headerlink" title="Overlay VS Device mapper"></a>Overlay VS Device mapper</h5><blockquote><p>Overlay是文件级存储，Device mapper是块级存储，当文件特别大而修改的内容很小，Overlay不管修改的内容大小都会复制整个文件，对大文件进行修改显示要比小文件要消耗更多的时间，而块级无论是大文件还是小文件都只复制需要修改的块，并不是整个文件，在这种场景下，显然device mapper要快一些。因为块级的是直接访问逻辑盘，适合IO密集的场景。而对于程序内部复杂，大并发但少IO的场景，Overlay的性能相对要强一些。</p></blockquote><h5 id="Device-mapper-VS-Btrfs-Driver-VS-ZFS"><a href="#Device-mapper-VS-Btrfs-Driver-VS-ZFS" class="headerlink" title="Device mapper VS Btrfs Driver VS ZFS"></a>Device mapper VS Btrfs Driver VS ZFS</h5><blockquote><p>Device mapper和Btrfs都是直接对块操作，都不支持共享存储，表示当有多个容器读同一个文件时，需要生活多个复本，所以这种存储驱动不适合在高密度容器的PaaS平台上使用。而且在很多容器启停的情况下可能会导致磁盘溢出，造成主机不能工作。Device mapper不建议在生产使用。Btrfs在docker build可以很高效。<br>ZFS最初是为拥有大量内存的Salaris服务器设计的，所在在使用时对内存会有影响，适合内存大的环境。ZFS的COW使碎片化问题更加严重，对于顺序写生成的大文件，如果以后随机的对其中的一部分进行了更改，那么这个文件在硬盘上的物理地址就变得不再连续，未来的顺序读会变得性能比较差。ZFS支持多个容器共享一个缓存块，适合PaaS和高密度的用户场景。</p></blockquote><h4 id="IO性能对比"><a href="#IO性能对比" class="headerlink" title="IO性能对比"></a>IO性能对比</h4><blockquote><p>测试工具：IOzone（是一个文件系统的benchmark工具，可以测试不同的操作系统中文件系统的读写性能）<br>测试场景：从4K到1G文件的顺序和随机IO性能<br>测试方法：基于不同的存储驱动启动容器，在容器内安装IOzone，执行命令：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./iozone -a -n 4k -g 1g -i 0 -i 1 -i 2 -f /root/test.rar -Rb ./iozone.xls</span><br></pre></td></tr></table></figure><h5 id="测试项的定义和解释"><a href="#测试项的定义和解释" class="headerlink" title="测试项的定义和解释"></a>测试项的定义和解释</h5><blockquote><p>Write：测试向一个新文件写入的性能。<br>Re-write：测试向一个已存在的文件写入的性能。<br>Read：测试读一个已存在的文件的性能。<br>Re-Read：测试读一个最近读过的文件的性能。<br>Random Read：测试读一个文件中的随机偏移量的性能。<br>Random Write：测试写一个文件中的随机偏移量的性能。</p></blockquote><h5 id="测试数据对比"><a href="#测试数据对比" class="headerlink" title="测试数据对比"></a>测试数据对比</h5><blockquote><p>Write：</p><p><a href="http://dockone.io/uploads/article/20190702/f592fe0e47c24441541b3970f6775674.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/f592fe0e47c24441541b3970f6775674.jpg" alt="8.jpg"></a></p><p>Re-write:</p><p><a href="http://dockone.io/uploads/article/20190702/778f51a47542033e0ded1b1b1d0edd63.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/778f51a47542033e0ded1b1b1d0edd63.jpg" alt="9.jpg"></a></p><p>Read：</p><p><a href="http://dockone.io/uploads/article/20190702/3028c70ce9a0abcfa673459b199612a3.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/3028c70ce9a0abcfa673459b199612a3.jpg" alt="10.jpg"></a></p><p>Re-Read：</p><p><a href="http://dockone.io/uploads/article/20190702/fb9fe60305c941fbfbc564cb2351e588.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/fb9fe60305c941fbfbc564cb2351e588.jpg" alt="11.jpg"></a></p><p>Random Read：</p><p><a href="http://dockone.io/uploads/article/20190702/ef273f23ee51927344a224ef3798e75a.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/ef273f23ee51927344a224ef3798e75a.jpg" alt="12.jpg"></a></p><p>Random Write：</p><p><a href="http://dockone.io/uploads/article/20190702/3a07e8a8a9b4de99602d02dc849b771b.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/3a07e8a8a9b4de99602d02dc849b771b.jpg" alt="13.jpg"></a></p></blockquote><ul><li>通过以上的性能数据可以看到：<ul><li>AUFS在读的方面性能相比Overlay要差一些，但在写的方面性能比Overlay要好。</li><li>device mapper在512M以上文件的读写性能都非常的差，但在512M以下的文件读写性能都比较好。</li><li>btrfs在512M以上的文件读写性能都非常好，但在512M以下的文件读写性能相比其他的存储驱动都比较差。</li><li>ZFS整体的读写性能相比其他的存储驱动都要差一些。 简单的测试了一些数据，对测试出来的数据原理还需要进一步的解析。</li></ul></li></ul><blockquote><p><code>Docker</code> 提供了可插拔的存储驱动程序架构。它使我们能够灵活地 <code>插入</code> <code>Docker</code>中的存储驱动程序。他完全基于<code>Linux</code>文件系统 。</p></blockquote><blockquote><p>要实现这一功能，我们必须 在<code>docker</code> 守护进程的开始时就设置驱动程序。 <code>Docker</code> 守护程序只能运行一个存储驱动程序，并且该守护程序实例创建的所有容器使用相同的存储驱动程序。</p></blockquote><ul><li><p>当前存储驱动</p><ul><li>查看守护程序使用哪个存储驱动程序，可以使用一下命令。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker info</span><br></pre></td></tr></table></figure><blockquote><p>可以看到上面的命令显示了守护进程使用的存储驱动程序。备份文件系统 <code>extfs</code> 。 <code>extfs</code> 表示覆盖存储驱动程序在文件系统的顶部运行。</p><p>后备文件系统实质用于在 <code>/var/lib/docker</code> 录下创建 <code>Docker</code> 主机的本地存储区域的文件系统。</p></blockquote><ul><li><p>下表包含必须与主机备份文件系统相匹配的存储驱动程序。</p><table><thead><tr><th align="center">存储驱动</th><th align="center">常用</th><th align="center">已禁用</th></tr></thead><tbody><tr><td align="center">overlay</td><td align="center">ext4xfs</td><td align="center">btrfs  aufs  overlayzfs  eCryptfs</td></tr><tr><td align="center">overlay2</td><td align="center">ext4xfs</td><td align="center">btrfs  aufs  overlayzfs  eCryptfs</td></tr><tr><td align="center">aufs</td><td align="center">ext4xfs</td><td align="center">btrfs  aufs  eCryptfs</td></tr><tr><td align="center">aufs</td><td align="center">btrfsonly</td><td align="center">N/A</td></tr><tr><td align="center">devicemapper</td><td align="center">Direct-lvm</td><td align="center">N/A</td></tr><tr><td align="center">vfs</td><td align="center">debugging only</td><td align="center">N/A</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">N/A</td></tr></tbody></table></li></ul><blockquote><p>注意 ：- “已禁用/Disabled on” 表示某些存储驱动程序无法在某些后台文件系统上运行</p></blockquote></li></ul><h4 id="设置存储驱动程序"><a href="#设置存储驱动程序" class="headerlink" title="设置存储驱动程序"></a>设置存储驱动程序</h4><blockquote><p>可以通过 <code>dockersd</code>命令按指定名称来设置存储驱动程序。以下命令启动守护程序并设置新的驱动程序。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dockerd --storage-driver=devicemapper</span><br></pre></td></tr></table></figure><blockquote><p>稍后，可以通过 <code>docker info</code> 命令检查 <code>docker</code> 服务驱动程序</p></blockquote><hr><p><strong>对于某些容器，直接将数据放在由</strong> storage driver <strong>维护的层中是很好的选择，比如那些无状态的应用。无状态意味着容器没有需要持久化的数据，随时可以从镜像直接创建。即存在与否依赖镜像的存在。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 如一些工具箱，启动是为了执行命令，不需要保存数据供以后使用，使用完直接退出，容器删除时存在容器层的工作数据也一起删除，这没问题，下次启动新容器即可。</span><br><span class="line"></span><br><span class="line"># 但对于另一类应用这种方式就不合适了，它们有持久化数据的需求，容器启动时需要加载已有的数据，容器销毁时希望保留产生的新数据，也就是说，这类容器是有状态的，例如数据库。</span><br><span class="line">这就要用到docker 的另一个存储机制：data volume</span><br></pre></td></tr></table></figure><h3 id="Data-Volume（数据卷）"><a href="#Data-Volume（数据卷）" class="headerlink" title="Data Volume（数据卷）"></a>Data Volume（数据卷）</h3><hr><blockquote><p>对于有些容器，我们可能会持久化数据的需求，也就是容器启动时需要加载已有的数据，容器销毁时希望保留产生的数据，也就是说这类容器是有状态的。</p><p>这就需要用到 <code>Docker</code> 的 <code>Data Volume</code> 存储机制。<code>Data Volume</code>本质上是 <code>Docker host</code>文件系统中的目录或文件，能够直接被 <code>mount</code> 到容器的文件系统。</p><p>在具体的使用上，<code>Docekr</code> 提供了两种类型的Volume：bind mount 和docker managed volume。</p></blockquote><h5 id="附：bind-mount-与-docker-managed-volume-的区别"><a href="#附：bind-mount-与-docker-managed-volume-的区别" class="headerlink" title="附：bind mount 与 docker managed volume 的区别"></a>附：bind mount 与 docker managed volume 的区别</h5><ul><li>这两种 <strong>data volume</strong> 实际上都是使用 <strong>host</strong> 文件系统的中的某个路径作为 <strong>mount</strong> 源。它们不同之处在于：</li></ul><table><thead><tr><th><strong>不同点</strong></th><th><strong>bind mount</strong></th><th><strong>docker managed volume</strong></th></tr></thead><tbody><tr><td><strong>volume 位置</strong></td><td>可任意指定</td><td><strong>/var/lib/docker/volumes/…</strong></td></tr><tr><td><strong>对已有mount point 影响</strong></td><td>隐藏并替换为 <strong>volume</strong></td><td>原有数据复制到 <strong>volume</strong></td></tr><tr><td><strong>是否支持单个文件</strong></td><td>支持</td><td>不支持，只能是目录</td></tr><tr><td><strong>权限控制</strong></td><td>可设置为只读，默认为读写权限</td><td>无控制，均为读写权限</td></tr><tr><td><strong>移植性</strong></td><td>移植性弱，与 <strong>host path</strong> 绑定</td><td>移植性强，无需指定 <strong>host</strong> 目录</td></tr></tbody></table><h5 id="什么是数据卷"><a href="#什么是数据卷" class="headerlink" title="什么是数据卷"></a>什么是数据卷</h5><ul><li><p>Data Volume 数据卷 ：是可以存放在一个或多个容器内的 <strong>特定的目录</strong>，提供独立于容器之外的<strong>持久化存储</strong>；是经过<strong>特殊设计的目录</strong>，可以绕过联合文件系统（UFS），为一个或多个容器提供访问；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Docker Contrainer</span><br><span class="line">面向对象中的对象</span><br><span class="line"></span><br><span class="line">对象一旦被销毁，数据就不存在了</span><br><span class="line"></span><br><span class="line">容器一旦被销毁，则容器内的数据将一并被删除</span><br><span class="line"></span><br><span class="line">服务器中的图案也会一并销毁</span><br><span class="line"></span><br><span class="line">容器中的数据不是持久化状态的</span><br></pre></td></tr></table></figure><blockquote><p>不使用 <code>volume</code>的时候，对容器进行的改动是不会被保存的，使用 <code>volume</code>可以实现持久化存储；比如运行一个数据的操作，数据库的一个容器，数据库的数据应该被持久化存储的，<code>volume</code>就可以实现这个，并且 <code>volume</code>可以提供容器与容器之间的共享数据；</p></blockquote></li></ul><h5 id="Docker-的理念之一："><a href="#Docker-的理念之一：" class="headerlink" title="Docker 的理念之一："></a>Docker 的理念之一：</h5><blockquote><p>就是将其应用于其运行的环境打包，因此，通过<code>Docker</code> 容器的生存周期，都是与容器中运行的程序相一致的，而我们对数据的要求通常是持久化的；另一方面，<code>docker</code>容器之间也需要有一个 <strong>共享数据的渠道</strong> ，而这些需求就催生出了<code>docker</code>数据卷的产生；</p></blockquote><h5 id="数据卷的设计的目的："><a href="#数据卷的设计的目的：" class="headerlink" title="数据卷的设计的目的："></a>数据卷的设计的目的：</h5><blockquote><p>在于 <strong>数据的永久化</strong> ，它完全独立于容器的生存周期，因此，<code>Docekr</code>不会在容器删除时删除其挂载的数据卷，也不会存在类似垃圾收集机制，对容器引用的数据卷进行处理了；</p></blockquote><h5 id="数据卷特点："><a href="#数据卷特点：" class="headerlink" title="数据卷特点："></a>数据卷特点：</h5><ul><li><ol><li><code>Docker</code>数据卷是独立于<code>Docker</code>的存在，它存在于<code>Docker host</code>（宿主机）中，因此，它与容器的生存周期是分离的；</li><li><code>Docker</code>数据卷本质上是存在于<code>Docker</code>宿主机的本地文件系统中；</li><li><code>Docker</code> 数据卷可以是目录也可以是文件；（不是块设备）</li><li><code>Docker</code> 容器可以利用数据卷的技术与容器宿主机进行数据共享；</li><li>同一个目录或者文件，可以支持多个容器进行访问，这样其实实现了容器的数据共享和交换；</li><li>数据卷是在容器启动是进行初始化的，那么如果容器使用的镜像包含了的数据也会在容器启动时拷贝到容器的数据卷中；</li><li><code>数据卷可以在容器之间共享和重用</code>；</li><li><code>数据卷的修改会立马生效</code>；容器可以对数据卷里的内容直接修改；容器对数据卷进行的修改是及时的，所有的修改都会直接体现在数据卷中；</li><li><code>数据卷的更新不会影响镜像</code>；因为文件不会写到镜像中去，数据卷是独立于联合文件系统的，而镜像本身基于联合文件系统，so镜像与数据卷之间不会有相互影响的情况；</li><li><code>数据卷会一直存在，即使挂载数据卷的容器已经删除</code>因为数据均本质上是宿主机上的一个目录，同时为了提供数据的永久化，它的生存周期与容器是完全隔离的；</li></ol><p><img src="https://img-blog.csdnimg.cn/20190617160156293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTQ2ODkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><blockquote><p>Docker 容器中的数据操作经过了UFS 的，UFS 会在宿主机中写一次文件，这个文件在宿主机上是临时的，这时候就出现了重复写的情况，会影响系统的性能；此外，删除容器的时候，就没有人能够通过UFS 在访问到宿主机中的文件了；</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190617160937555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTQ2ODkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>容器卷可以绕过 UFS 直接操作主机上的文件，当容器删除的时候，宿主机上的文件还在，就在指定的目录下，在重新创建容器的时候们可以指定容器继续读取宿主机上的文件；</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190617161045446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTQ2ODkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h5><blockquote><p>包含数据卷挂载的容器在容器关闭时，如果修改了宿主机下的数据卷会，容器里面会产生改变吗？ </p></blockquote><ul><li><strong>bind mount 数据卷</strong></li></ul><blockquote><p>使用docker run –name nginx-test -p 8080:80 -d -v ~/myvolume:/usr/share/nginx/html nginx  创建一个bind mount 数据卷 是宿主机的存储位置必须是绝对路径。目录不存在则会生成</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 以下两种情况创建的数据卷如果浏览器访问宿主机的ip:8080 会出现报错，因为这是创建的时候清空了容器数据卷下index.html</span><br><span class="line"># 创建的宿主机和容器的数据卷都有读写的权限</span><br><span class="line">$ docker run --name nginx-test -p 8080:80 -d -v ~/myvolume:/usr/share/nginx/html nginx</span><br><span class="line"># 这样执行后的文件宿主机的~/myvolume 文件如果不存在直接创建，容器的文件路径不存在也会直接创建，如果/usr/share/nginx/html文件存在里面内容会清空</span><br><span class="line"></span><br><span class="line"># 给容器里面的数据卷加权限</span><br><span class="line">$ docker run --name nginx-test -p 8080:80 -d -v ~/myvolume:/usr/share/nginx/html:ro nginx</span><br><span class="line"># 如果执行这个 :/usr/share/nginx/html:ro这个地方加的是 :ro 是设置的只有读取权限</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 运行dockers inspect 容器名称或容器（ID） 是将容器的配置文件已json字符串的形式返回</span><br><span class="line">&quot;Binds&quot;: [</span><br><span class="line">                &quot;/root/myvolume:/usr/share/nginx/html&quot;   # 宿主机数据卷位置: 容器的目录位置</span><br><span class="line">            ],</span><br><span class="line"></span><br><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;bind&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/root/myvolume&quot;,   # 是宿主机数据卷的存储位置</span><br><span class="line">                &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,   # 权限 true是可以读写 fales 是只读</span><br><span class="line">                &quot;Propagation&quot;: &quot;rprivate&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 在宿主机的数据卷下执行:</span><br><span class="line">vim index.html </span><br><span class="line"># 在文件里写入hello ， 你在访问的时候就可以在页面上看到你写入得数据了</span><br></pre></td></tr></table></figure><blockquote><p>执行 docker exec -it 容器名称（容器ID） bahs进入到容器里面，每个容器都会包含一个迷你版的linux系统</p><p>执行 cd /usr/share/nginx/html  </p><p>执行 ls</p><p>你会看到容器目录里会有我们刚才创建好的文件</p><p>index.html</p><p>执行 cat index.html  可以看到里面我们加入的数据</p><p>如果是挂载数据卷的时候加 <code>:ro</code> 容器内修改文件，发现会提示该文件是只读的  </p></blockquote><hr><ul><li><strong>docker managed volume 数据卷</strong><ul><li>创建出来的两个都是有读写权限的</li></ul></li></ul><blockquote><p>使用docker run –name nginx-test2 -p 8080:80 -d -v /usr/share/nginx/html nginx 创建一个<strong>docker managed volume 数据卷</strong> </p><p>这种命令创建是不用指定宿主机数据卷存储位置的默认在 /var/lib/docker/volumes/ 下的文件名是经过<code>sha256</code> 摘要过的</p></blockquote><ul><li>查看宿主机创建出来的数据卷</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cd  /var/lib/docker/volumes/</span><br><span class="line">$ ls </span><br><span class="line">8d668720aaeccee44b5fb554571912a6a257eb3a28cecf334203805a0c9b6fd3  #这是自己创建出来的数据卷</span><br><span class="line"># 执行 cd _data 进入这这个文件夹里面</span><br><span class="line">$ ls</span><br><span class="line">50x.html  index.html   # 这两个文件是把容器里文件给拷贝了出来</span><br></pre></td></tr></table></figure><blockquote><p>可以在宿主机或者容器里面都可以对文件进行读写操作</p></blockquote><h5 id="挂载多个目录实现数据卷的"><a href="#挂载多个目录实现数据卷的" class="headerlink" title="挂载多个目录实现数据卷的"></a>挂载多个目录实现数据卷的</h5><ul><li>就是执行多个 <code>-v</code> 就可以</li></ul><h5 id="容器间的数据共享"><a href="#容器间的数据共享" class="headerlink" title="容器间的数据共享"></a>容器间的数据共享</h5><ul><li>数据卷容器挂载了一个本地文件系统的目录，其它容器通过挂载这个数据卷容器来实现容器间的数据的共享；</li></ul><p><img src="https://img-blog.csdn.net/20180524134945342?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTQ2ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h5 id="容器间挂载"><a href="#容器间挂载" class="headerlink" title="容器间挂载"></a>容器间挂载</h5><blockquote><p>创建数据卷，只要在<code>docker run</code>命令后面跟上<code>-v</code>参数即可创建一个数据卷，当然也可以跟多个<code>-v</code>参数来创建多个数据卷，当创建好带有数据卷的容器后，就可以在其他容器中通过<code>--volumes-from</code>参数来挂载该数据卷了，而不管该容器是否运行。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -tid --rm --volumes-from nginx-test --name nginx-test3 nginx</span><br></pre></td></tr></table></figure><blockquote><p>-i  : 以交互模式运行容器，通常与 -t 同时使用；</p><p>-t  : 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p><p>-d : 后台运行容器，并返回容器ID；</p></blockquote><ul><li>再创建一个nginx-test4，挂载nginx-test3中从nginx-test挂载的数据卷，当然也可以直接挂载初识的nginx-test容器的数据卷</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 即使删除了初始的数据卷容器 nginx-test，或者是删除了其他容器，但只要是有容器在使用该数据卷，那么它里面的数据就不会丢失</span><br><span class="line">* 命令中的rm表示当容器退出即停止的时候，会自动删除该容器</span><br></pre></td></tr></table></figure><hr><h5 id="备份数据卷"><a href="#备份数据卷" class="headerlink" title="备份数据卷"></a>备份数据卷</h5><ul><li>创建一个容器container1，包含两个数据卷/usr/share/nginx/html1和/usr/share/nginx/html2（这两个目录是在容器里的数据卷路径）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -tid -v /usr/share/nginx/html1 -v /usr/share/nginx/html2 --name container1 -p 8080:80 nginx</span><br><span class="line"># 创建容器container1</span><br><span class="line"></span><br><span class="line">$ docker exec -it container1 bash   #进入创建好的容器里面</span><br><span class="line"></span><br><span class="line">$ cd html1/  # 进入到html1数据卷中</span><br><span class="line">$ echo html1 &gt;&gt; 1.text # 向 1.text 文件中追加数据，文件不存在则会创建文件</span><br><span class="line"></span><br><span class="line">$ cd html2/  # 进入到html2数据卷中</span><br><span class="line">$ echo html2 &gt;&gt; 2.text # 向 2.text 文件中追加数据，文件不存在则会创建文件</span><br></pre></td></tr></table></figure><ul><li>接下来进行数据卷的备份操作</li></ul><blockquote><p>使用  - -volumes-from 来创建一个加载 container1 容器卷的容器，并从宿主机挂载当前所在目录到容器的 /backup 目录，容器内会 tar 压缩 /var/colume1 目录下的文件到 /backup/backup1.tar，因为宿主机当前目录已经映射到 /backup 目录了，因此会在宿主机当前目录也存在该压缩包。备份完毕后 -rm 自动删除该创建的容器。</p></blockquote><ul><li>备份container1容器中的/usr/share/nginx/html1数据卷数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 备份container1容器中的/usr/share/nginx/html1数据卷数据</span><br><span class="line"># -tid 这个参数加不加都可以</span><br><span class="line"># --rm 加上，备份后就会自动删除这个容器，如果不加这个 --rm 参数，name备份后的容器就会保留，docker ps -a就会查看到）</span><br><span class="line"># $(pwd) </span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# pwd</span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# docker run -tid --rm --volumes-from container1 -v $(pwd):/backup nginx tar cvf /backup/backup1.tar /usr/share/nginx/html1</span><br><span class="line">b3663a3bdd302a38036d6a156471cd448c8e5b9333a20f9480b3c61cbd9270df</span><br><span class="line"></span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# ls</span><br><span class="line">backup1.tar</span><br></pre></td></tr></table></figure><blockquote><ul><li>–volumes-from [containerName]：这个命令来指定需要备份的容器的名字；（数据卷容器的名字）</li><li>-v $(pwd):/backup:权限：使用-v命令来指定希望备份文件存放的位置；本地存放目录：容器存放目录：读写权限；（默认权限是读写）</li><li>tar cvf /backup/backup.tar [container data volume]：tar表示执行备份的操作是：压缩文件的命令；</li><li>/backup/backup.tar是文件存放的地址， [container data volume]指定需要备份的目录；</li><li>tar cvf 压缩；tar xvf解压缩；</li></ul></blockquote><ul><li>备份container1容器中的/usr/share/nginx/html2数据卷数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 备份container1容器中的/usr/share/nginx/html2数据卷数据</span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# pwd</span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# docker run -tid --rm --volumes-from container1 -v $(pwd):/backup nginx tar cvf /backup/backup2.tar /usr/share/nginx/html2</span><br><span class="line">001129bc393d5d0ed4665d053d4ca7972584cf2bd56980064be182ec758138cd</span><br><span class="line"></span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# ll</span><br><span class="line">total 22464</span><br><span class="line">-rw-r--r-- 1 root root    10240 Dec 16 18:52 backup1.tar  # 文件1</span><br><span class="line">-rw-r--r-- 1 root root    10240 Dec 16 19:05 backup2.tar  # 文件2</span><br><span class="line">drwxr-xr-x 2 root root     4096 Dec 16 16:45 myvolume</span><br><span class="line">-rw-r--r-- 1 root root 22973527 Mar 26  2019 Python-3.7.3.tgz</span><br></pre></td></tr></table></figure><ul><li>备份container1 容器中的 /usr/share/nginx/html1 和 /usr/share/nginx/html2 数据卷数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#  备份container1 容器中的 /usr/share/nginx/html2 和 /usr/share/nginx/html2 数据卷数据</span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# pwd</span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# docker run -tid --rm --volumes-from container1 -v $(pwd):/backup nginx tar cvf /backup/backup.tar /usr/share/nginx/html1 /usr/share/nginx/html2</span><br><span class="line">441df929e123cbe51564ca3d6bf3f06a5ea415298a34bb9871f1ed2b68a60102</span><br><span class="line"></span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# ll</span><br><span class="line">total 22476</span><br><span class="line">-rw-r--r-- 1 root root    10240 Dec 16 18:52 backup1.tar</span><br><span class="line">-rw-r--r-- 1 root root    10240 Dec 16 19:05 backup2.tar</span><br><span class="line">-rw-r--r-- 1 root root    10240 Dec 16 19:09 backup.tar</span><br><span class="line">drwxr-xr-x 2 root root     4096 Dec 16 16:45 myvolume</span><br><span class="line">-rw-r--r-- 1 root root 22973527 Mar 26  2019 Python-3.7.3.tgz</span><br></pre></td></tr></table></figure><h5 id="恢复数据给同一个容器"><a href="#恢复数据给同一个容器" class="headerlink" title="恢复数据给同一个容器"></a>恢复数据给同一个容器</h5><blockquote><p>之前的数据卷是从 container1 中备份的，现在模拟 container1 数据卷丢失，然后直接用之前备份的 backup.tar 进行恢复</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"># 为了测试恢复，先删除容器里原先的数据（注意：数据卷目录不能删除，只能删除其中的数据）</span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# docker exec -it container1 bash </span><br><span class="line">#进入到创建的容器里</span><br><span class="line">root@6869560e6ff5:/# ls</span><br><span class="line">bin  boot  devetc  home  liblib64  media  mnt  optproc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@6869560e6ff5:/# cd /usr/share/nginx  </span><br><span class="line">#进入到容器里面的数据卷所在的目录</span><br><span class="line">root@6869560e6ff5:/usr/share/nginx# ls</span><br><span class="line">html  html1  html2  </span><br><span class="line"></span><br><span class="line">root@6869560e6ff5:/usr/share/nginx# cd html1</span><br><span class="line"># 进入到 html1 数据卷目录</span><br><span class="line">root@6869560e6ff5:/usr/share/nginx/html1# ls</span><br><span class="line">1.text</span><br><span class="line"></span><br><span class="line">root@6869560e6ff5:/usr/share/nginx/html1# rm -rf 1.text </span><br><span class="line"># 删除 1.text 文件</span><br><span class="line">root@6869560e6ff5:/usr/share/nginx/html1# ls</span><br><span class="line"></span><br><span class="line">root@6869560e6ff5:/usr/share/nginx# cd html2</span><br><span class="line"># 进入到 html2 的数据卷目录</span><br><span class="line">root@6869560e6ff5:/usr/share/nginx/html2# ls</span><br><span class="line">2.text</span><br><span class="line"></span><br><span class="line">root@6869560e6ff5:/usr/share/nginx/html2# rm -rf 2.text </span><br><span class="line"># 删除 2.text 文件</span><br><span class="line">root@6869560e6ff5:/usr/share/nginx/html2# ls</span><br><span class="line"></span><br><span class="line"># 进行数据卷恢复，恢复数据卷中的所有数据</span><br><span class="line">注意-C后面的路径，表示将数据恢复到容器里的路径直接使用压缩包中文件的各个路径。比如压缩包中的结果如下：</span><br><span class="line">tar -xvf backup.tar   #解压压缩文件</span><br><span class="line"></span><br><span class="line"># 数据1</span><br><span class="line">usr/share/nginx/html1/1.text</span><br><span class="line">--usr</span><br><span class="line">--share</span><br><span class="line">--nginx</span><br><span class="line">--html1</span><br><span class="line">--1.text</span><br><span class="line"># 数据2</span><br><span class="line">usr/share/nginx/html2/2.text</span><br><span class="line">--usr</span><br><span class="line">--share</span><br><span class="line">--nginx</span><br><span class="line">--html2</span><br><span class="line">--2.text</span><br><span class="line"># 直接将文件解压到 /usr/share/nginx/html1 和 /usr/share/nginx/html2 目录</span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# docker run --rm --volumes-from container1 -v $(pwd):/backup nginx tar xvf /backup/backup.tar -C /</span><br><span class="line">usr/share/nginx/html1/</span><br><span class="line">usr/share/nginx/html1/1.text</span><br><span class="line">usr/share/nginx/html2/</span><br><span class="line">usr/share/nginx/html2/2.text</span><br><span class="line"></span><br><span class="line"># 直接进入容器查看</span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# docker exec -it container1 bash</span><br><span class="line">root@6869560e6ff5:/# cd /usr/share/nginx/ </span><br><span class="line">root@6869560e6ff5:/usr/share/nginx# ls</span><br><span class="line">html  html1  html2</span><br><span class="line"># 查看数据是否存在</span><br><span class="line">root@6869560e6ff5:/usr/share/nginx# ls html1</span><br><span class="line">1.text</span><br><span class="line">root@6869560e6ff5:/usr/share/nginx# ls html2</span><br><span class="line">2.text</span><br><span class="line">root@6869560e6ff5:/usr/share/nginx# cat html1/1.text </span><br><span class="line">html1</span><br><span class="line">root@6869560e6ff5:/usr/share/nginx# cat html2/2.text </span><br><span class="line">html2</span><br></pre></td></tr></table></figure><h5 id="恢复数据给新的容器"><a href="#恢复数据给新的容器" class="headerlink" title="恢复数据给新的容器"></a>恢复数据给新的容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 新建一个容器container2</span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# docker run -tid -v /usr/share/nginx/html1 -v /usr/share/nginx/html2 --name container2 nginx</span><br><span class="line">89abb55858fb1e3dddc07c2066d05614349aaf78ba446a1ea12f1241b98e4896</span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">89abb55858fb        nginx               &quot;/bin/bash&quot;         9 seconds ago       Up 8 seconds        80/tcp              container2</span><br><span class="line">6869560e6ff5        nginx               &quot;/bin/bash&quot;         2 hours ago         Up 2 hours          80/tcp              container1</span><br><span class="line"></span><br><span class="line"># 开始恢复数据</span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# pwd</span><br><span class="line">/root</span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# ll</span><br><span class="line">total 22476</span><br><span class="line">-rw-r--r-- 1 root root    10240 Dec 16 18:52 backup1.tar</span><br><span class="line">-rw-r--r-- 1 root root    10240 Dec 16 19:05 backup2.tar</span><br><span class="line">-rw-r--r-- 1 root root    10240 Dec 16 19:09 backup.tar</span><br><span class="line">drwxr-xr-x 2 root root     4096 Dec 16 16:45 myvolume</span><br><span class="line">-rw-r--r-- 1 root root 22973527 Mar 26  2019 Python-3.7.3.tgz</span><br><span class="line"></span><br><span class="line"># 恢复数据</span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# docker run --rm --volumes-from container2 -v $(pwd):/backup nginx tar xvf /backup/backup.tar -C /</span><br><span class="line">usr/share/nginx/html1/</span><br><span class="line">usr/share/nginx/html1/1.text</span><br><span class="line">usr/share/nginx/html2/</span><br><span class="line">usr/share/nginx/html2/2.text</span><br><span class="line"></span><br><span class="line"># 查看确实已经恢复了</span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# docker exec -it container2 bash</span><br><span class="line">root@89abb55858fb:/# ls /usr/share/nginx/</span><br><span class="line">html  html1  html2</span><br><span class="line">root@89abb55858fb:/# ls /usr/share/nginx/html1</span><br><span class="line">1.text</span><br><span class="line">root@89abb55858fb:/# ls /usr/share/nginx/html2</span><br><span class="line">2.text</span><br><span class="line">root@89abb55858fb:/# cat /usr/share/nginx/html1/1.text </span><br><span class="line">html1</span><br><span class="line">root@89abb55858fb:/# cat /usr/share/nginx/html2/2.text </span><br><span class="line">html2</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li><p>–volumes-from [containerName]：这个命令来指定需要备份的容器的名字；（数据卷容器的名字）</p></li><li><p>-v $(pwd):/backup:权限：使用-v命令来指定希望备份文件存放的位置；本地存放目录：容器存放目录：读写权限；（默认权限是读写）</p></li><li><p>tar cvf /backup/backup.tar [container data volume]：tar表示执行备份的操作是：压缩文件的命令；</p></li><li><p>/backup/backup.tar是文件存放的地址， [container data volume]指定需要备份的目录；</p></li><li><p>tar cvf 压缩；tar xvf解压缩；</p></li><li><p>新容器创建时挂载的数据卷路径最好和之前备份的数据卷路径一致</p></li><li><p>新容器创建时，如果挂载的数据卷只是备份卷的一部分，那么恢复的时候也只是恢复一部分数据。</p></li><li><p>比如新建容器挂载数据卷为 <code>-v /usr/share/nginx/html1</code> ,那么使用 <code>backup.tar</code> 恢复时，只会恢复 <code>/usr/share/nginx/html1</code> 的数据， <code>/usr/share/nginx/html2</code> 的数据是不会恢复的</p></li><li><p>比如新容器创建时挂载的数据卷目录和备份的数据卷目录不一致，那么数据恢复不了，除非修改 - C 后面的路径，比如新建容器时指定数据卷目录为 <code>/usr/share/nginx/html</code> ，恢复时也是用 <code>-C /usr/share/nginx/html</code>，则是可以成功恢复的</p></li></ul></blockquote><h5 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls     列出所有的数据卷</span><br><span class="line">docker volume ls --filter dangling=true     过滤不在使用的数据卷</span><br><span class="line">docker volume rm [volume name]     删除一个数据卷，容器正在使用的数据卷不能删除，绑定挂载的数据卷无法删除</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm my-volio  删除数据卷 my-volio</span><br></pre></td></tr></table></figure><blockquote><p>数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令。</p></blockquote><ul><li>无主的数据卷可能会占据很多空间，要清理请使用以下命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume prune</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#Docker 存储&lt;/p&gt;&lt;h3 id=&quot;Docek-镜像层的镜像分层结构&quot;&gt;&lt;a href=&quot;#Docek-镜像层的镜像分层结构&quot; class=&quot;headerlink&quot; title=&quot;Docek 镜像层的镜像分层结构&quot;&gt;&lt;/a&gt;Docek 镜像层的镜像分层结构&lt;/h3&gt;
    
    </summary>
    
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>手动定义一个全局中间件</title>
    <link href="http://yoursite.com/2060/07/18/%E6%89%8B%E5%8A%A8%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://yoursite.com/2060/07/18/手动定义一个全局中间件/</id>
    <published>2060-07-17T16:00:00.000Z</published>
    <updated>2019-12-26T01:59:59.049Z</updated>
    
    <content type="html"><![CDATA[<h3 id="手动定义一个全局中间件"><a href="#手动定义一个全局中间件" class="headerlink" title="手动定义一个全局中间件"></a>手动定义一个全局中间件</h3><blockquote><p>创建一个 middlerware.py（名字可以自己定义一个） 的文件</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 导入 MiddlewareMixin</span><br><span class="line"># 没有这个模块就下载一个</span><br><span class="line">from django.utils.deprecation import MiddlewareMixin</span><br><span class="line"># 导入</span><br><span class="line">from django.shortcuts import reverse</span><br><span class="line">from django.http import JsonResponse</span><br><span class="line">import time</span><br><span class="line">from .views import decrypt_oralce</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">LOGIN_REQUIRE_LIST = [reverse(var) for var in []] # 定义一个全局监控的路由列表，表里添加路由名</span><br><span class="line"># LoginRequired 函数名需要到 settings.py 里面进行配置,如下</span><br><span class="line"># 列表里面放的是需要登录判断的路由</span><br><span class="line">LOGIN_REQUIRE_LIST = [reverse(var) for var in []]</span><br><span class="line">class LoginRequired(MiddlewareMixin):</span><br><span class="line">    def process_request(self,request):</span><br><span class="line">        # 重定义请求来临需要做的事情</span><br><span class="line">        # 判断请求是否需要登录</span><br><span class="line">        # request.path()  # 返回当前用户访问的路径</span><br><span class="line">        # print(request.META[&apos;HTTP_AUTHORIZATION&apos;])</span><br><span class="line">        if request.path in LOGIN_REQUIRE_LIST:</span><br><span class="line">            token = request.META.get(&apos;HTTP_AUTHORIZATION&apos;) </span><br><span class="line">            if not token or token == &apos;null&apos;:</span><br><span class="line">                return JsonResponse(&#123;</span><br><span class="line">                    &apos;code&apos;:6207,</span><br><span class="line">                    &apos;message&apos;:&apos;未认证登录&apos;</span><br><span class="line">                &#125;)</span><br><span class="line">            else:</span><br><span class="line">                # 逆向解析</span><br><span class="line">                token_data = json.loads(decrypt_oralce(token))</span><br><span class="line">                user_id = token_data.get(&apos;id&apos;)</span><br><span class="line">                if token_data[&apos;expire&apos;] &lt; time.time():</span><br><span class="line">                    # token 过期</span><br><span class="line">                    return JsonResponse(&#123;</span><br><span class="line">                        &apos;code&apos;:7001,</span><br><span class="line">                        &apos;message&apos;:&apos;登陆时间已过期&apos;</span><br><span class="line">                    &#125;)</span><br><span class="line">                data = request.POST.copy()</span><br><span class="line">                data[&apos;id&apos;] = user_id</span><br><span class="line">                request.POST = data</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># settings.py配置</span><br><span class="line">MIDDLEWARE = [</span><br><span class="line">    &apos;django.middleware.security.SecurityMiddleware&apos;,</span><br><span class="line">    &apos;django.contrib.sessions.middleware.SessionMiddleware&apos;,</span><br><span class="line">    &apos;corsheaders.middleware.CorsMiddleware&apos;,</span><br><span class="line">    &apos;django.middleware.common.CommonMiddleware&apos;,</span><br><span class="line">    # &apos;django.middleware.csrf.CsrfViewMiddleware&apos;,</span><br><span class="line">    &apos;django.contrib.auth.middleware.AuthenticationMiddleware&apos;,</span><br><span class="line">    &apos;django.contrib.messages.middleware.MessageMiddleware&apos;,</span><br><span class="line">    &apos;django.middleware.clickjacking.XFrameOptionsMiddleware&apos;,</span><br><span class="line">    &apos;peng.middlerware.LoginRequired&apos;,  # LoginRequired -&gt; 这个名字就是你在 middlerware.py里面的函数名 加一行这个注册一下</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>views.py  里面</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"># 密码加密</span><br><span class="line">import hashlib</span><br><span class="line">from django.contrib.auth.hashers import make_password,check_password</span><br><span class="line"></span><br><span class="line"># 全局中间件</span><br><span class="line">import itsdangerous</span><br><span class="line">from shiyanpro.settings import SECRET_KEY</span><br><span class="line"></span><br><span class="line"># AES 加密算法容器</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import base64</span><br><span class="line">import json</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># Create your views here.</span><br><span class="line"></span><br><span class="line"># 定义memcache连接对象 </span><br><span class="line">mem = memcache.Client([&apos;47.96.189.157&apos;])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BLOCK_SIZEE = 16</span><br><span class="line">AES_KEY = &apos;wxpeng&apos;   # key 值一定是16、32等</span><br><span class="line">EXPIRE = 3000</span><br><span class="line">def add_16(value):</span><br><span class="line">    while len(value) % 16 != 0:</span><br><span class="line">        value += &apos;\0&apos;</span><br><span class="line">    return str.encode(value) </span><br><span class="line"></span><br><span class="line">def add_32(value):</span><br><span class="line">    while len(value) % 32 != 0:</span><br><span class="line">        value += &apos;\0&apos;</span><br><span class="line">    return str.encode(value)</span><br><span class="line"></span><br><span class="line"># ECB 加密</span><br><span class="line">def encrypt_oracle(text):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">        text的格式：</span><br><span class="line">        text:&#123;&apos;name&apos;:&apos;zhangsan,&apos;id&apos;:3&#125;</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    aes = AES.new(add_32(AES_KEY),AES.MODE_ECB)</span><br><span class="line">    encrypt_value = aes.encrypt(add_16(text)) # text --&gt;  需要加密的东西</span><br><span class="line">                                              # ECB 模式加密，内容必须是‘进制流’</span><br><span class="line">    encrypt_text = str(base64.encodebytes(encrypt_value),encoding=&apos;utf-8&apos;)</span><br><span class="line">    print(encrypt_text)</span><br><span class="line">    return encrypt_text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ECB 解密</span><br><span class="line">def decrypt_oralce(text):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">        text的格式：</span><br><span class="line">        text:&#123;&apos;name&apos;:&apos;zhangsan,&apos;id&apos;:3&#125;</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    aes = AES.new(add_32(AES_KEY),AES.MODE_ECB)</span><br><span class="line">    base64_decrypted = base64.decodebytes(text.encode(encoding=&apos;utf-8&apos;))</span><br><span class="line">    decrypted_text = str(aes.decrypt(base64_decrypted),encoding=&apos;utf-8&apos;).replace(&apos;\0&apos;,&apos;&apos;)</span><br><span class="line">    return decrypted_text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 生成token函数</span><br><span class="line">def jwt_itsdangerous_token(user):</span><br><span class="line">    jwt_ = itsdangerous.TimedJSONWebSignatureSerializer(SECRET_KEY,300)  </span><br><span class="line">    data = &#123;</span><br><span class="line">                &apos;id&apos;:user.id,</span><br><span class="line">            &#125;</span><br><span class="line">    token = jwt_.dumps(data).decode()</span><br><span class="line">    return token</span><br><span class="line"></span><br><span class="line"># 定义密码加密函数</span><br><span class="line">def get_pass(str_):</span><br><span class="line">    s = hashlib.sha1()</span><br><span class="line">    s.update(str_.encode())</span><br><span class="line">    return s.hexdigest()</span><br><span class="line"></span><br><span class="line"># 在登录接口中，账号密码验证成功的情况下，写入如下代码，</span><br><span class="line">data = &#123;</span><br><span class="line">                &apos;id&apos;:user.id,</span><br><span class="line">                &apos;expire&apos;:time.time() + EXPIRE # token 过期时间</span><br><span class="line">            &#125;</span><br><span class="line">            token = encrypt_oracle(json.dumps(data))</span><br><span class="line">            return JsonResponse(&#123;</span><br><span class="line">                &apos;code&apos;:1,</span><br><span class="line">                &apos;message&apos;:&apos;登录成功&apos;,</span><br><span class="line">                &apos;token&apos;:token</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>前端判断返回的 code 是否是 6027 或 7001 就OK</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;手动定义一个全局中间件&quot;&gt;&lt;a href=&quot;#手动定义一个全局中间件&quot; class=&quot;headerlink&quot; title=&quot;手动定义一个全局中间件&quot;&gt;&lt;/a&gt;手动定义一个全局中间件&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;创建一个 middlerware.py（名字可以自己定义一个） 的文件&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Docker（2）</title>
    <link href="http://yoursite.com/2056/02/12/Docker%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2056/02/12/Docker概念/</id>
    <published>2056-02-11T16:00:00.000Z</published>
    <updated>2019-12-26T01:58:35.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h1><p>Docker 是一个开源的应用容器引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在本地编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。</p><a id="more"></a><p>简单的理解，Docker类似于集装箱，各式各样的货物，经过集装箱的标准化进行托管，而集装箱和集装箱之间没有影响。也就是说，Docker平台就是一个软件集装箱化平台，这就意味着我们自己可以构建应用程序，将其依赖关系一起打包到一个容器中，然后这容器就很容易运送到其他的机  器上进行运行，而且非常易于装载、复制、移除，非常适合软件弹性架构。 </p><p>因此，就像船只、火车或卡车运输集装箱而不论其内部的货物一样，软件容器充当软件部署的标准单元，其中可以包含不同的代码和依赖项。 按照这种方式容器化软件，开发人员和 IT 专业人员只需进行极少修改或不修改，即可将其部署到不同的环境。</p><p>总而 言之，Docker 是一个开放平台，使开发人员和管理员可以在称为容器的松散隔离的环境中构建镜像、交付和运行分布式应用程序。以便在开发、QA 和生产环境之间进行高效的应用程序生命周期管理。</p><h1 id="Docker能解决什么问题"><a href="#Docker能解决什么问题" class="headerlink" title="Docker能解决什么问题"></a>Docker能解决什么问题</h1><p>高效有序利用资源</p><ul><li>机器资源有限；</li><li>单台机器得部署多个应用；</li><li>应用之间互相隔离；</li><li>应用之间不能发生资源抢占，每个应用只能使用事先注册申请的资源。</li></ul><p>一次编译，到处运行</p><ul><li>类似于java代码，应用及依赖的环境构建一次，可以到处运行</li></ul><h1 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h1><p>Docker使用C/S架构，Client 通过接口与Server进程通信实现容器的构建，运行和发布。client和server可以运行在同一台集群，也可以通过跨主机实现远程通信。</p><p><img src="https://img-blog.csdnimg.cn/20181108181808777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NsZXZlckNvZGU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="Docker核心原理"><a href="#Docker核心原理" class="headerlink" title="Docker核心原理"></a>Docker核心原理</h1><h3 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h3><p>命名空间（namespaces）是 Linux 为我们提供的用于分离进程树、网络接口、挂载点以及进程间通信等资源的方法。在日常使用 Linux 或者 macOS 时，我们并没有运行多个完全分离的服务器的需要，但是如果我们在服务器上启动了多个服务，这些服务其实会相互影响的，每一个服务都能看到其他服务的进程，也可以访问宿主机器上的任意文件，这是很多时候我们都不愿意看到的，我们更希望运行在同一台机器上的不同服务能做到完全隔离，就像运行在多台不同的机器上一样。</p><p><a href="http://dockone.io/uploads/article/20190625/6498a2be3f3ddcb2a032df838ac24069.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190625/6498a2be3f3ddcb2a032df838ac24069.png" alt="3.png"></a></p><p>在这种情况下，一旦服务器上的某一个服务被入侵，那么入侵者就能够访问当前机器上的所有服务和文件，这也是我们不想看到的，而 Docker 其实就通过 Linux 的 Namespaces 对不同的容器实现了隔离。</p><p>Linux 的命名空间机制提供了以下七种不同的命名空间，包括 CLONE_NEWCGROUP、CLONE_NEWIPC、CLONE_NEWNET、CLONE_NEWNS、CLONE_NEWPID、CLONE_NEWUSER 和 CLONE_NEWUTS，通过这七个选项我们能在创建新的进程时设置新进程应该在哪些资源上与宿主机器进行隔离。</p><h1 id="Docker镜像原理"><a href="#Docker镜像原理" class="headerlink" title="Docker镜像原理"></a>Docker镜像原理</h1><ol><li><h2 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h2><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件, 它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p></li></ol><h3 id="1-1-UnionFS-联合文件系统"><a href="#1-1-UnionFS-联合文件系统" class="headerlink" title="1.1 UnionFS(联合文件系统)"></a>1.1 UnionFS(联合文件系统)</h3><p>UnionFS(联合文件系统): Union文件系统(UnionFS)是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承, 基于基础镜像(没有父镜像)， 可以制作各种具体的应用镜像。<br>特性: 一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><h3 id="1-2-Docker镜像加载原理"><a href="#1-2-Docker镜像加载原理" class="headerlink" title="1.2 Docker镜像加载原理"></a>1.2 Docker镜像加载原理</h3><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p><p><strong>bootfs(boot file system)</strong>主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的, 包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p><p>rootfs(root file system), 在bootfs之上。包含的就是典型Linux系统中的/dev, /proc, /bin, /etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p><p>平时我们安装虚拟机的CentOS都是好几个G，为什么docker这里才200M？linux mini 200G 2G </p><p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就行了。由此可见对于不同的linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以共用bootfs。</p><h3 id="1-3-分层的镜像"><a href="#1-3-分层的镜像" class="headerlink" title="1.3 分层的镜像"></a>1.3 分层的镜像</h3><p>以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载</p><h3 id="1-4-为什么docker镜像要采用这种分层结构呢"><a href="#1-4-为什么docker镜像要采用这种分层结构呢" class="headerlink" title="1.4 为什么docker镜像要采用这种分层结构呢"></a>1.4 为什么docker镜像要采用这种分层结构呢</h3><p>最大的一个好吃就是共享资源<br>比如：有多个镜像都从相同的base镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像,同时内存中也只需加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p><ol start="2"><li><h4 id="镜像的特点"><a href="#镜像的特点" class="headerlink" title="镜像的特点"></a>镜像的特点</h4><p>Docker镜像都是只读的<br>当容器启动时，一个新的可写层被加载到镜像的顶部。<br>这一层通常被称作为”容器层”，“容器层”之下的都叫”镜像层”。</p></li></ol><h1 id="Docker容器原理"><a href="#Docker容器原理" class="headerlink" title="Docker容器原理"></a>Docker容器原理</h1><p><strong>Docker 容器通过 Docker 镜像来创建，容器与镜像的关系类似于面向对象编程中的对象与类。</strong></p><p>如图所示基本架构：</p><p><img src="http://p3.pstatp.com/large/pgc-image/1536290868344c25780cff9" alt="阿里P8架构师谈:Docker容器的原理、特征、基本架构、与应用场景"></p><p><strong>Docker 镜像(Images)</strong></p><p>Docker 镜像是用于创建 Docker 容器的模板。</p><p><strong>Docker 容器(Container)</strong></p><p>容器是独立运行的一个或一组应用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是Docker&quot;&gt;&lt;a href=&quot;#什么是Docker&quot; class=&quot;headerlink&quot; title=&quot;什么是Docker&quot;&gt;&lt;/a&gt;什么是Docker&lt;/h1&gt;&lt;p&gt;Docker 是一个开源的应用容器引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在本地编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>创建有一个新的 Django 项目</title>
    <link href="http://yoursite.com/2050/10/10/%E5%88%9B%E5%BB%BAdjango%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2050/10/10/创建django项目/</id>
    <published>2050-10-09T16:00:00.000Z</published>
    <updated>2019-12-26T01:59:47.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建一个新的-Django-项目"><a href="#创建一个新的-Django-项目" class="headerlink" title="创建一个新的 Django 项目"></a>创建一个新的 Django 项目</h2><a id="more"></a><pre><code>- Django-admin startproject 项目名称- Cd 到 创建的 django 项目中- 创建子项目：- Python manage.py startapp 子项目名- Python manage.py createsuperuser 创建超级用户管理员- Python manage.py runserver 启动项目</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创建一个新的-Django-项目&quot;&gt;&lt;a href=&quot;#创建一个新的-Django-项目&quot; class=&quot;headerlink&quot; title=&quot;创建一个新的 Django 项目&quot;&gt;&lt;/a&gt;创建一个新的 Django 项目&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Django-Views-视图层</title>
    <link href="http://yoursite.com/2032/12/09/Django-Views-%E8%A7%86%E5%9B%BE%E5%B1%82/"/>
    <id>http://yoursite.com/2032/12/09/Django-Views-视图层/</id>
    <published>2032-12-08T16:00:00.000Z</published>
    <updated>2019-12-26T01:58:22.272Z</updated>
    
    <content type="html"><![CDATA[<h3 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h3><blockquote><p>视图函数一般用来接收一个<code>Web</code>请求<code>HttpRequest</code>，之后返回一个Web响应<code>HttpResponse</code></p></blockquote><a id="more"></a><h4 id="HttpRequest"><a href="#HttpRequest" class="headerlink" title="HttpRequest"></a>HttpRequest</h4><blockquote><p>一个视图函数用来响应用户的<code>Request</code>请求，每个视图函数默认的第一个位置参数<code>request</code>用来接收用户发起请求的<code>HttpRequest</code>信息。</p><p>视图函数的返回值，为一个<code>HttpResponse</code>值，包括我们要返回给用户的<code>HTML</code>页面或者字符串等等，以及对应的头部字段信息</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line"><span class="keyword">return</span> HttpResponse(<span class="string">'Hello world'</span>)</span><br></pre></td></tr></table></figure><h4 id="常见请求方式"><a href="#常见请求方式" class="headerlink" title="常见请求方式"></a>常见请求方式</h4><blockquote><p><code>POST</code>和<code>GET</code>是<code>HTTP</code>协议定义的与服务器交互的方法。</p><p><code>GET</code>一般用于获取/查询资源信息，而<code>POST</code>一般用于更新资源信息。另外，还有<code>PUT</code>和<code>DELETE</code>方法</p></blockquote><h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><blockquote><p>常用来从指定地址请求数据；</p><p>如果需要在请求时提交某些数据，则以路由形式传递参数，查询<code>Query</code>字符串如下格式所示：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/?key=abc&amp;pos=hebei</span><br></pre></td></tr></table></figure><ul><li><code>get</code>请求可被浏览器缓存，保存在历史记录中</li><li><code>get</code>不应在使用敏感数据时使用，明文包路在请求地址中</li><li><code>get</code>有长度限制</li></ul><h5 id="post"><a href="#post" class="headerlink" title="post"></a>post</h5><blockquote><p>向指定的资源提交要被处理的数据</p><p>使用<code>POST</code>，提交的数据保存在<code>HTTP</code>协议中的消息主体部分</p></blockquote><ul><li><code>post</code>请求不会被浏览器缓存</li><li><code>post</code>提交数据长度无限制</li><li><code>post</code>比<code>get</code>更加安全</li></ul><h4 id="request"><a href="#request" class="headerlink" title="request"></a>request</h4><blockquote><p>如果说<code>urls.py</code>是<code>Django</code>中前端页面和后台程序桥梁，那么<code>request</code>就是桥上负责运输的小汽车，可以说后端接收到的来至前端的信息几乎全部来自于<code>requests</code>中</p></blockquote><h5 id="request-method"><a href="#request-method" class="headerlink" title="request.method"></a>request.method</h5><blockquote><p>获取当前用户请求方式，</p><p>请求方式字符串为纯大写：<code>&#39;GET&#39;</code>、<code>&#39;POST&#39;</code></p><p>如用户以<code>get</code>方式发起请求，对应代码中获取到的结果以及在判断时像是这样</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line"><span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">…</span><br></pre></td></tr></table></figure><h5 id="request-GET"><a href="#request-GET" class="headerlink" title="request.GET"></a>request.GET</h5><blockquote><p>当用户通过<code>get</code>方式请求站点，并在路由中提供了查询参数，可以通过该属性获取到对应提交的值</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    print(request.GET) </span><br><span class="line">    <span class="comment"># &lt;QueryDict: &#123;'name': ['jack'], 'id': ['1']&#125;&gt;</span></span><br><span class="line">    print(type(request.GET)) </span><br><span class="line">    <span class="comment"># &lt;class 'django.http.request.QueryDict'&gt;</span></span><br><span class="line">    name_ = request.GET.get(<span class="string">'name'</span>)</span><br><span class="line">    id_ = request.GET.get(<span class="string">'id'</span>)</span><br><span class="line">    content = <span class="string">'%s:%s'</span> % (name_,id_)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(content)</span><br></pre></td></tr></table></figure><blockquote><p><code>request.GET</code>是一个类似字典的数据类型：<code>QueryDict</code></p><p>其中也支持类似对字典的<code>get</code>或直接<code>dict.[key]</code>键值访问方式，当然使用<code>get</code>方式进行对应<code>key</code>获取会更好，因为<code>get</code>在访问不到时不会报错</p></blockquote><ul><li>如果定义了如上所示的视图函数，那么在访问连接时，我们可以通过路由传参：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8000/?name=jack&amp;id=1</span><br></pre></td></tr></table></figure><ul><li>这里对应页面会显示的结果：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jack:1</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：使用<code>GET</code>方法在连接中进行参数提交，后台接收到的数据类型均是字符串</p></blockquote><hr><h5 id="request-POST"><a href="#request-POST" class="headerlink" title="request.POST"></a>request.POST</h5><blockquote><p>获取用户以<code>post</code>形式提交的数据并保存在后台，为类字典数据，这里和<code>request.GET</code>是一个东西；</p><p>在网页中，一般我们通过<code>html</code>的表单进行数据的提交，<code>POST</code>方式可以提交空数据</p></blockquote><ul><li>因为涉及到了表单页面，所以我们先来弄一个<code>HTML</code>页面</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>这是一个关于POST的测试<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">        &#123;% csrf_token %&#125;</span><br><span class="line">        账号:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"account"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"passwd"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在模板页面中，一旦涉及到了表单提交，那么一定要注意在表单区域添加<code>csrf_token</code>标签进行防跨站伪造令牌的加载，否则表单数据的将被认为是无效的。</p></blockquote><blockquote><p>在接下来的视图函数中会使用到<code>input</code>标签中的<code>name</code>属性；</p><p><code>name</code>值属性维护了<code>post</code>的数据传入到后台时的标示，会与表单的数据组合成类字典格式</p><p>如<code>name</code>属性为<code>account</code>的输入框中输入了<code>test</code>，那么后台数据接收到的值类似：<code>{&#39;account&#39;:&#39;test&#39;}</code></p></blockquote><ul><li>写一个视图函数用来捕获当前表单使用POST形式提交的数据：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method=<span class="string">"POST"</span>:</span><br><span class="line">        print(request.POST)</span><br><span class="line">        print(type(request.POST))</span><br><span class="line">        account = request.POST.get(<span class="string">"account"</span>)</span><br><span class="line">        passwd = request.POST.get(<span class="string">"passwd"</span>)</span><br><span class="line">        content = <span class="string">"%s:%s"</span> % (account,passwd)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(content)</span><br><span class="line">   <span class="keyword">return</span> render(request,<span class="string">"index.html"</span>) <span class="comment">#在使用get形式请求时，返回表单页面</span></span><br></pre></td></tr></table></figure><ul><li>如果在表单页面中账号填写为test，密码为123456；在视图函数中捕捉到的结果为：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;QueryDict: &#123;&apos;csrfmiddlewaretoken&apos;: [&apos;EmyGwsVcrXI2LDkYLS9qflkUH4N7bM1nfTQxr3fsOsZlI4vJFwci7TargtYRAGl2&apos;], &apos;account&apos;: [&apos;test&apos;], &apos;passwd&apos;: [&apos;123456&apos;]&#125;&gt;</span><br></pre></td></tr></table></figure><h6 id="表单夺表提交"><a href="#表单夺表提交" class="headerlink" title="表单夺表提交"></a>表单夺表提交</h6><blockquote><p>在<code>request.POST</code>中需要注意，某些情况下，使用POST提交数据的表单数据可能是多个值，类似复选框<code>CheckBox</code>，直接使用<code>request.POST.get()</code>进行获取是有一些问题的，比如修改模板页`面如下所示</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"taste"</span> <span class="attr">value</span>=<span class="string">"eat"</span>&gt;</span>吃</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"taste"</span> <span class="attr">value</span>=<span class="string">"sleep"</span>&gt;</span>睡</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"taste"</span> <span class="attr">value</span>=<span class="string">"play"</span>&gt;</span>耍</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这是一个<code>name</code>值为<code>taste</code>的兴趣爱好采集的多选框，<code>value</code>值将会作为选中时，提交到后台的值，比如现在我们全选这些表单数据，那么后台接收到的值是这样的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;QueryDict: &#123;&apos;csrfmiddlewaretoken&apos;: [&apos;nuaLzxc2E0artYKUZiefMPv5iHTX5gLFY1sCu8wi1vrKqpVFTWh7EnlCR64Hua5k&apos;], &apos;taste&apos;: [&apos;eat&apos;, &apos;sleep&apos;, &apos;play&apos;]&#125;&gt;</span><br></pre></td></tr></table></figure><blockquote><p>但是问题接踵而至，我们发现使用<code>get</code>函数获取不到对应全选的整个结果，而是只拿到了选中的最后一项</p></blockquote><ul><li><p><code>request.POST.get(key, default=None)</code></p><blockquote><p>返回对应<code>key</code>值的数据中的<strong>最后一个</strong>数据单独返回；<code>key</code>值不存在，取<code>default</code></p></blockquote></li></ul><blockquote><p>要想真正拿出所有的结果，应该使用<code>getlist</code>函数</p></blockquote><ul><li><p><code>request.POST.getlist(key, default=None)</code></p><blockquote><p>将对应<code>key</code>值的所有数据以<strong>一个列表</strong>形式返回；<code>key</code>值不存在，取<code>default</code></p></blockquote></li></ul><h5 id="request-META"><a href="#request-META" class="headerlink" title="request.META"></a>request.META</h5><blockquote><p><code>request.MAT</code>E获取的是一个标准的<code>python</code>字典。它包含了所有的<code>HTTP</code>请求信息</p><p>比如用户IP地址和用户<code>Agent</code>（通常是浏览器的名称和版本号）。</p><p>注意，<code>Header</code>信息的完整列表取决于用户所发送的<code>Header</code>信息和服务器端设置的<code>Header</code>信息</p></blockquote><ul><li><code>CONTENT_LENGTH</code>：请求的正文的长度，字符串类型</li><li><code>CONTENT_TYPE</code>：请求的正文的<code>MIME</code> 类型</li><li><code>HTTP_ACCEPT</code>：响应可接收的<code>Content-Type</code></li><li><code>HTTP_ACCEPT_ENCODING</code>：响应可接收的编码</li><li><code>HTTP_ACCEPT_LANGUAGE</code>：响应可接收的语言</li><li><code>HTTP_HOST</code>：客服端发送的<code>HTTP Host</code>头部</li><li><code>HTTP_REFERER</code>：请求前的连接地址</li><li><code>HTTP_USER_AGENT</code>：客户端的<code>user-agent</code>字符串</li><li><code>QUERY_STRING</code>：单个字符串形式的查询字符串（未解析过的形式）</li><li><code>REMOTE_ADDR</code>：客户端的IP 地址</li><li><code>REMOTE_HOST</code>：客户端的主机名</li><li><code>REMOTE_USER</code>：服务器认证后的用户</li><li><code>REQUEST_METHOD</code>：一个字符串，例如<code>GET</code> 或<code>POST</code></li><li><code>SERVER_NAME</code>：服务器的主机名</li><li><code>SE0RVER_PORT</code>：服务器的端口，字符串类型</li></ul><h5 id="request-FILES"><a href="#request-FILES" class="headerlink" title="request.FILES"></a>request.FILES</h5><blockquote><p>接收用户上传文件及相关信息。同样类似于<code>request.POST</code>，提取到的数据为一个类字典的数据类型，包含所有文件上传的信息</p></blockquote><ul><li><p><code>f = request.FILES.get(&#39;upload_file&#39;)</code></p><blockquote><p><code>file_data = f.read()</code>：读取整个上传文件的内容，适合小文件上传</p><p><code>yiled = f.chunks()</code>：返回一个类似生成器<code>（&lt;class &#39;generator&#39;&gt;）</code>的数据，每一次读取按块返回文件，可以通过<code>for</code>迭代访问其中数据；适合上传大文件到服务器。</p><p><code>f.multiple_chunks()</code>：返回文件大小，当文件大小大于<code>2.5M</code>时，返回<code>True</code>，反之返回<code>False</code>，可以通过该函数来选择是否使用<code>chunks</code>方法或<code>read</code>直接存储。</p><p>如果想要修改这个文件判定的默认值，可以通过：<code>FILE_UPLOAD_MAX_MEMORY_SIZE</code>在<code>settings</code>文件下进行设置</p><p><code>f.content_type</code>：上传文件时头部中的<code>Content-Type</code>字段值，参考MIME类型</p><p><code>f.name</code>：上传文件名字</p><p><code>f.charset</code>：上传文件编码</p><p><code>f.size</code>： 上传文件大小，字节为单位：<code>byte</code></p></blockquote></li></ul><blockquote><p>创建好静态资源目录，并在下面创建一个<code>img</code>文件夹，保存我们即将上传的图片；</p><p>完成上传文件的<code>HTML</code>表单页面</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"upload_file"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"&#123;% static 'img/1.jpg' %&#125;"</span> <span class="attr">alt</span>=<span class="string">"这是一张图片"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里使用的是即将要上传的文件名字，只做文件是否上传成功的简单测试 --&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：上传文件的页面表单，一定要记得设置属性<code>enctype=&quot;multipart/form-data&quot;</code></p></blockquote><ul><li>视图函数如下编写，接收上传图片，并保存在静态目录下刚才创建好的img目录中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">"POST"</span>:</span><br><span class="line">        f = request.FILES.get(<span class="string">"upload_files"</span>)</span><br><span class="line">        path = os.path.join(settings.STATICFILES_DIRS[<span class="number">0</span>],<span class="string">'img/'</span>+f.name)</span><br><span class="line">  <span class="comment"># 上传文件本地保存路径</span></span><br><span class="line">        <span class="keyword">with</span> open(path,<span class="string">'wb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            <span class="keyword">if</span> f.multiple_chunks: <span class="comment">#判断到上传文件为大于2.5MB的大文件</span></span><br><span class="line">                <span class="keyword">for</span> buf <span class="keyword">in</span> f.chunks(): <span class="comment">#迭代写入文件</span></span><br><span class="line">                    fp.write(buf)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                fp.write(f.read())</span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">"Success!"</span>)</span><br><span class="line">  <span class="keyword">return</span> render(request, <span class="string">'index.html'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>测试上传一个名为<code>1.jpg</code>的图片，如果成功上传，那么后台<code>static</code>目录下会出现该图片，并且模板页面也可以展示对应图片效果</p></blockquote><h4 id="HTTPResponse"><a href="#HTTPResponse" class="headerlink" title="HTTPResponse"></a>HTTPResponse</h4><blockquote><p>一个视图的返回值经常是为了向用户返回一个<code>HttpResponse</code>响应，</p><p>有如下常用的可以返回<code>HttpResponse</code>的函数</p></blockquote><h5 id="response"><a href="#response" class="headerlink" title="response"></a>response</h5><ul><li><p><code>HttpResponse(content=b&#39;&#39;)</code></p><blockquote><p>返回一个字符串内容</p><p><em>from</em> django.http <em>import</em> HttpResponse</p></blockquote></li><li><p><code>render(request,template_name,context=None,content_type=None,status=None)</code></p><blockquote><p>返回一个可渲染HTML页面，状态码为<code>200</code></p><p><em>from</em> django.shortcuts <em>import</em> render</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; request`：固定参数，响应的`request`请求，来自于参数部分接收的`HttpRequest</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><code>template_name</code>：返回的模板页面路径</p><p><code>context</code>：模板页面渲染所需的数据，默认为字典格式</p><p><code>content_type</code>：生成之后的结果使用的<code>MIME</code>类型</p><p><code>status</code>：响应的状态码，默认为<code>200</code></p></blockquote></li><li><p>redirect(to, permanent=False)</p><blockquote><p>一个重定向，浏览器通过该状态码自动跳转到一个新的路由地址，默认返回响应状态码<code>302</code></p><p><em>from</em> django.shortcuts <em>import</em> redirect</p></blockquote><blockquote><p><code>to</code>：可以是一个<code>django</code>项目中视图函数的路由映射，也可以是一个<code>reverse</code>的反向路由解析</p><p><code>permanent</code>：如果设置为<code>True</code>，将返回<code>301</code>状态码，代表永久重定向</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">302</span>：临时重定向，旧地址资源临时不能用了，搜索引擎只会暂时抓取新地址的内容而保存旧的地址。</span><br><span class="line"><span class="number">301</span>：永久重定向，旧地址资源已经不复存在，搜索引擎不光会抓取新地址的内容，还会替换旧地址为新地址</span><br></pre></td></tr></table></figure></li></ul><h4 id="视图错误处理"><a href="#视图错误处理" class="headerlink" title="视图错误处理"></a>视图错误处理</h4><blockquote><p>为了方便我们开发，<code>django</code>提供了一个异常叫做<code>Http404</code>异常，我们可以在视图函数的代码中按照需求进行抛出，抛出之后<code>django</code>项目会自动捕获该异常，并会展示默认的<code>404</code>页面</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> Http404</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.GET.get(<span class="string">"id"</span>) == <span class="string">"1"</span>:</span><br><span class="line">        <span class="keyword">raise</span> Http404</span><br></pre></td></tr></table></figure><blockquote><p>在<code>settings</code>中的<code>debug</code>配置项为<code>false</code>时，访问<code>http://127.0.0.1:8000/?id=1</code>，可以看到<code>django</code>为我们提供的错误页面；</p><p>除了<code>django</code>默认提供的，我们还可以可以在模板目录下定义全局<code>404.html</code>进行错误页面的定制</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">    抱歉，找不到你要的东西</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="自定义错误处理视图"><a href="#自定义错误处理视图" class="headerlink" title="自定义错误处理视图"></a>自定义错误处理视图</h5><blockquote><p>除去<code>404</code>错误的自定义，<code>django</code>还提供了覆盖默认错误行为处理的办法；</p><p>有些时候，<code>django</code>自动的错误处理可能不能满足我们的需求，那么我们可以重新定义一些新的视图函数，</p><p>来覆盖掉<code>django</code>所提供的错误处理视图函数，最后在<code>urls.py</code>路由配置文件下通过定义全局变量来重新设置默认的错误处理视图函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">handler404：覆盖page_not_found()视图。</span><br><span class="line">handler500：覆盖server_error()视图。</span><br><span class="line">handler403：覆盖permission_denied()视图。</span><br><span class="line">handler400：覆盖bad_request()视图。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">''</span>, include(<span class="string">"viewapp.urls"</span>)),</span><br><span class="line">]</span><br><span class="line">handler404 = <span class="string">"viewapp.views.error_404"</span></span><br><span class="line"><span class="comment"># APP.模块.视图函数</span></span><br><span class="line">handler500 = <span class="string">"viewapp.views.error_500"</span></span><br></pre></td></tr></table></figure><blockquote><p>相关定义好的错误处理视图函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_404</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"这是404错误"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_403</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"这是403错误"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_500</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"这是500错误"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;视图层&quot;&gt;&lt;a href=&quot;#视图层&quot; class=&quot;headerlink&quot; title=&quot;视图层&quot;&gt;&lt;/a&gt;视图层&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;视图函数一般用来接收一个&lt;code&gt;Web&lt;/code&gt;请求&lt;code&gt;HttpRequest&lt;/code&gt;，之后返回一个Web响应&lt;code&gt;HttpResponse&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Mysql主从复制</title>
    <link href="http://yoursite.com/2031/08/11/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://yoursite.com/2031/08/11/Mysql主从复制/</id>
    <published>2031-08-10T16:00:00.000Z</published>
    <updated>2020-01-05T13:02:36.624Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mysql主从复制"><a href="#Mysql主从复制" class="headerlink" title="Mysql主从复制"></a>Mysql主从复制</h3><ul><li>什么是<strong>主从复制</strong>？</li></ul><a id="more"></a><blockquote><p>主从复制至少需要两台服务器，或两个<strong>mysql</strong>服务，可以配置一主多从，多主多从</p><p>建立与某个业务数据库一样的数据库环境，即为主从复制</p><p>一般情况下，主库用以写，而从库用以读</p></blockquote><ul><li>为什么要搭建主从复制？ <ul><li>构建主从热备，当某天数据库宕机或或数据丢失情况，可以有备份数据库继续工作</li><li>降低IO频次，多库之间可以合理分配读写压力，提高单个数据库服务的数据库访问压力</li><li>隔离读写，在某些锁表情况下，可以使数据库读操作继续进行</li></ul></li><li>主从复制原理 </li></ul><blockquote><p>利用数据库<strong>bin-log</strong>二进制文件，该文件包含有数据库操作的所有SQL语句 </p><p>复制该文件至其余数据库服务中并执行即可</p></blockquote><ul><li><p>主从复制过程 </p><ul><li><p>当主库具有新数据时，主库会被从库请求，建立线程进行连接，用以传输<strong>binlog</strong>日志</p></li><li><p>从库开启两个线程</p><blockquote><p>A线程：也叫做<strong>IO线程</strong>，连接主库，并请求binlog中的更新记录至从库中，写入至从库的<strong>relaylog</strong>文件中</p><p>B线程：也叫做<strong>SQL线程</strong>，读取<strong>relaylog</strong>文件中的更新操作并执行</p></blockquote></li><li><p>如果，有多个从库同时存在，主库会为每个从库建立一个<strong>binlog</strong>输出线程 </p></li></ul></li></ul><p><img src="/images/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B61-1.png" alt="1578228433821"></p><p>首先输入如下命令配置全局环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set global validate_password_policy=LOW;</span><br><span class="line"></span><br><span class="line">set global validate_password_length=6;</span><br></pre></td></tr></table></figure><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><blockquote><p>此处以一主一从为例 </p></blockquote><ul><li>系统环境<ul><li>主库（master）：47.96.189.157</li><li>从库（slave）：116.62.237.164</li></ul></li></ul><h3 id="主库修改"><a href="#主库修改" class="headerlink" title="主库修改"></a>主库修改</h3><ul><li>主库配置修改</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server-id = 1</span><br><span class="line">log-bin=mysql-bin # 开启log bin</span><br><span class="line">expire_logs_days=7 # 日志保存时间</span><br></pre></td></tr></table></figure><blockquote><p><strong>server-id</strong>：</p><p>同步数据中必须包含<strong>server-id</strong>，用于标识该语句最初是从哪个<strong>server</strong>写入</p><p>每个<strong>slave</strong>端只能有一个线程在<strong>master</strong>端连接，如果两个<strong>slave</strong>端的<strong>server-id</strong>一致，一个连接成功之后，前一个连接将会被断开</p><p>主主同步时，避免数据同步陷入死循环</p></blockquote><p><strong>修改完配置要记得重新启动下数据库</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure><ul><li>主库创建用户，用以从机连接获取<strong>binlog</strong>日志 ，密码根据实际情况来定</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant replication slave on *.* to &apos;master&apos;@&apos;%&apos; identified by &apos;123456&apos;;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to master@&apos;%&apos; identified by &quot;123456&quot;;</span><br></pre></td></tr></table></figure><ul><li>查看master状态</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure><ul><li>记录上条命令返回的<strong>binlog</strong>文件名，<strong>Position</strong>属性，从机连接的时候要用 </li></ul><p><img src="/images/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B61-2.png" alt="1578228433821"></p><h3 id="从库修改"><a href="#从库修改" class="headerlink" title="从库修改"></a>从库修改</h3><ul><li>从库配置修改 </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server-id=100</span><br></pre></td></tr></table></figure><blockquote><p><strong>master</strong>与<strong>slave</strong>端的<strong>server-id</strong>不能一样</p><p><strong>slave</strong>端无需开启<strong>log-bin</strong>功能</p><p><strong>还是不要忘记重新启动一下数据库</strong></p></blockquote><ul><li>从库指定master，执行如下 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change master to master_host=&apos;47.96.189.157&apos;, master_port=3306, master_user=&apos;master&apos;, master_password=&apos;123456&apos;, master_log_file=&apos;mysql-bin.000001&apos;, master_log_pos=154;</span><br></pre></td></tr></table></figure><ul><li>启动从机</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure><p>这样就ok啦！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Mysql主从复制&quot;&gt;&lt;a href=&quot;#Mysql主从复制&quot; class=&quot;headerlink&quot; title=&quot;Mysql主从复制&quot;&gt;&lt;/a&gt;Mysql主从复制&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;什么是&lt;strong&gt;主从复制&lt;/strong&gt;？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>DockerFile</title>
    <link href="http://yoursite.com/2031/06/30/DockerFile/"/>
    <id>http://yoursite.com/2031/06/30/DockerFile/</id>
    <published>2031-06-29T16:00:00.000Z</published>
    <updated>2019-12-26T01:58:29.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><h4 id="1、DockerFile简介"><a href="#1、DockerFile简介" class="headerlink" title="1、DockerFile简介"></a>1、DockerFile简介</h4><a id="more"></a><ul><li>DockerFile是用来构建Docker镜像的<strong>构建文件</strong>，是由一系列命令和参数构成的脚本</li><li>构建步骤（1）编写DockerFile文件（2）执行docker build（3）docker run</li></ul><h4 id="2、DockerFile构建过程解析"><a href="#2、DockerFile构建过程解析" class="headerlink" title="2、DockerFile构建过程解析"></a>2、DockerFile构建过程解析</h4><ul><li>编写规范<ul><li>每条保留字指令都必须为大写字母且必须跟参数：例如 FROM nginx</li><li>指令从上到下，顺序执行</li><li>#表示注释</li><li>每条指令都会创建一个新的镜像层，并对镜像进行提交</li></ul></li><li>编写步骤<ul><li>docker从基础镜像运行一个容器</li><li>执行一条指令并对容器做出修改</li><li>执行类似docker commit的操作提交一个新的镜像层</li><li>docker再基于刚提交的镜像运行一个新容器</li><li>执行dockerfile中的下一条指令直到所有指令都指向完成</li></ul></li></ul><blockquote><p>dockerfile、镜像、容器之间的关系可以类比为生产环境中的，原材料，交付品，运行的产品</p></blockquote><h4 id="3、常用关键字（语法）"><a href="#3、常用关键字（语法）" class="headerlink" title="3、常用关键字（语法）"></a>3、常用关键字（语法）</h4><table><thead><tr><th>关键字</th><th>释意</th></tr></thead><tbody><tr><td>FROM</td><td>基础镜像，当前新镜像的父镜像</td></tr><tr><td>MAINTAINER</td><td>镜像维护者的姓名和邮箱</td></tr><tr><td>RUN</td><td>容器构建需要运行的命令，用&amp;&amp;连接脚本可以减少镜像的层数</td></tr><tr><td>EXPOSE</td><td>当前容器对外暴露出的端口</td></tr><tr><td>WORKDIR</td><td>指定在创建容器后，终端默认登录进来的目录</td></tr><tr><td>ENV</td><td>构建过程中的环境变量</td></tr><tr><td>ADD</td><td>将宿主机文件拷贝进镜像内并解压缩</td></tr><tr><td>COPY</td><td>拷贝文件到镜像中</td></tr><tr><td>VOLUME</td><td>容器数据卷，数据保存和持久化</td></tr><tr><td>CMD</td><td>指定容器需要运行的命令，多个命令出现时只执行最后一个CMD命令</td></tr><tr><td>ENTRYPOINT</td><td>指定容器需要运行的命令</td></tr><tr><td>ONBUILD</td><td>当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像内触发</td></tr></tbody></table><h4 id="4、案例解析"><a href="#4、案例解析" class="headerlink" title="4、案例解析"></a>4、案例解析</h4><ul><li>以官方centos7镜像为例</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ADD centos-7-x86_64-docker.tar.xz /</span><br><span class="line"></span><br><span class="line">LABEL org.label-schema.schema-version="1.0" \</span><br><span class="line">    org.label-schema.name="CentOS Base Image" \</span><br><span class="line">    org.label-schema.vendor="CentOS" \</span><br><span class="line">    org.label-schema.license="GPLv2" \</span><br><span class="line">    org.label-schema.build-date="20191001"</span><br><span class="line"></span><br><span class="line">CMD ["/bin/bash"]</span><br></pre></td></tr></table></figure><blockquote><p>官方仓库里的centos为精简压缩版，我们可centos添加额外功能，例如：netstat查看所有端口。</p><p>尝试编写Dockerfile来实现这一功能</p></blockquote><p>任意目录下新建DockerFile空文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch DockerFile</span><br><span class="line">vi DockerFile</span><br></pre></td></tr></table></figure><p>写入可执行文本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">ENV mypath /home</span><br><span class="line">WORKDIR $mypath</span><br><span class="line">RUN yum -y install net-tools &amp;&amp; touch 1.txt</span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><p>docker build执行DockerFile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t centos:1.1 -f DockerFile .</span><br></pre></td></tr></table></figure><ul><li><p>-t  指定镜像的名字。[name:版本 =&gt; centos:1.1]</p></li><li><p>-f  显示指定构建镜像的 Dockerfile 文件（Dockerfile 可不在当前路径下）。如果不使用 -f，则默认将上下文路径下的名为 Dockerfile 的文件认为是构建镜像的 “Dockerfile” </p></li><li><p>.  这个表示打包的上下文（其实就是Dockerfile所在目录）是在当前目录。指定构建镜像的上下文的路径，构建镜像的过程中，可以且只可以引用上下文中的任何文件 </p></li></ul><blockquote><p>docker build 官方语法 “docker build [OPTIONS] PATH | URL | -”。</p><p>更多详情请参考：<a href="https://docs.docker.com/engine/reference/commandline/build/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/build/</a></p></blockquote><p>查看是否安装了netstat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i -d centos /bin/bash</span><br><span class="line">docker exec -it 容器id bash</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DockerFile&quot;&gt;&lt;a href=&quot;#DockerFile&quot; class=&quot;headerlink&quot; title=&quot;DockerFile&quot;&gt;&lt;/a&gt;DockerFile&lt;/h2&gt;&lt;h4 id=&quot;1、DockerFile简介&quot;&gt;&lt;a href=&quot;#1、DockerFile简介&quot; class=&quot;headerlink&quot; title=&quot;1、DockerFile简介&quot;&gt;&lt;/a&gt;1、DockerFile简介&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Django-Urls-路由层</title>
    <link href="http://yoursite.com/2031/06/11/Django-Urls-%E8%B7%AF%E7%94%B1%E5%B1%82/"/>
    <id>http://yoursite.com/2031/06/11/Django-Urls-路由层/</id>
    <published>2031-06-10T16:00:00.000Z</published>
    <updated>2019-12-27T09:22:45.524Z</updated>
    
    <content type="html"><![CDATA[<h4 id="路由层"><a href="#路由层" class="headerlink" title="路由层"></a>路由层</h4><blockquote><p>路由是Web服务的入口，就好像办事大厅有各个服务窗口一样</p></blockquote><a id="more"></a><blockquote><p>Django奉行DRY主义，提倡使用简洁、优雅的URL：</p><p> 可以不用<code>.html</code>、<code>.php</code>或<code>.cgi</code>之类后缀</p><p> 尽量不要单独使用无序随机数字这样无意义的东西</p><p> 让你随心所欲设计你的URL，不受框架束缚</p></blockquote><h5 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h5><h6 id="urlpatterns"><a href="#urlpatterns" class="headerlink" title="urlpatterns"></a>urlpatterns</h6><blockquote><p>urlpatterns是路由文件中的一个全局变量，用来存放路由及视图函数的映射关系</p><p>用户发起的请求<code>URL</code>都会首先进入主控制目录下的这个<code>urls.py</code>文件中进行查找匹配</p></blockquote><ol><li>首先找到<code>urls.py</code>下的<code>urlpatterns</code>全局变量，这是一个路由规则实例的列表数据。</li><li>按照先后定义顺序，进行路由匹配。</li><li>找到第一个匹配项时停止匹配，执行匹配到的视图函数。</li><li>遍历完全，未发现匹配，<code>django</code>进行异常处理</li></ol><blockquote><p>其中<code>urlpatterns</code>中的每一个路由映射规则可以由<code>path</code>或<code>re_path</code>进行构造</p></blockquote><blockquote><p><strong>注意</strong>：<code>Django</code>的路由不考虑<code>HTTP</code>请求方式，仅根据URL进行路由；即，只要<code>URL</code>相同，无论<code>POST</code>、<code>GET</code>等哪种请求方式都指向同一个操作函数</p></blockquote><h6 id="path"><a href="#path" class="headerlink" title="path"></a>path</h6><ul><li><p><code>path(regex, view, kwargs=None, name=None)</code></p><blockquote><p><code>regex</code>：一个匹配对应url地址的规则字符串。</p><p><code>view</code>：路由对应的视图函数，并且会自动封装HttpRequest作为第一个参数给这个视图函</p><p><code>kwargs</code>：视图函数的关键字参数。</p><p><code>name</code>：该路由的全局命名，可以让我们方便的在django项目中任意部分显示的使用，相当于为<code>url</code>取变量名，接下来全局使用该命名值即可；当对应<code>url</code>路由改变之后，结合路由反向解析使用的地方不需要更改路由</p><p>此外，<code>django</code>还提供了一个兼容老版本<strong>url</strong>路由配置函数的<strong>re_path</strong>函数；<code>re_path</code>：第一个参数部分为一个正则匹配规则，其他与path同</p></blockquote></li></ul><h5 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h5><blockquote><p>静态路由用来映射对应视图函数，以下是一个简单的例子</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Hello Worlds!'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,re_path</span><br><span class="line"><span class="keyword">from</span> urlapp <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">''</span>,views.index),</span><br><span class="line">    re_path(<span class="string">r"^"</span>,views.index),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h5><blockquote><p>有的时候，我们的路由设置不能一直维持一个一成不变的状态；</p><p>比如遇到一些内容翻页的场景，那么我们的连接可能是：<code>xx.com/airticle_list/1/</code>、<code>xx.com/airticle_list/2/</code></p><p>那么这样的路由其实对应的都应该是一个视图函数，用以展示页面内容，那么如何设计这样的路由，就要涉及到动态路由及路由传参</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request,x,y)</span>:</span></span><br><span class="line">    content = <span class="string">"x:%s\ny:%s"</span> % (x,y)  </span><br><span class="line"><span class="keyword">return</span> HttpResponse(content)</span><br></pre></td></tr></table></figure><blockquote><p>定义如上函数，将会接收连接中的后两部份<code>path</code>值作为参数，分别依次给到<code>x</code>和<code>y</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,re_path</span><br><span class="line"><span class="keyword">from</span> urlapp <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'&lt;int:x&gt;/&lt;str:y&gt;/'</span>,views.index),</span><br><span class="line">    <span class="comment">#指明类型</span></span><br><span class="line">    path(<span class="string">"&lt;x&gt;/&lt;y&gt;/"</span>,views.index)</span><br><span class="line">    <span class="comment">#不指明类型</span></span><br><span class="line">    re_path(<span class="string">r"^(?P&lt;x&gt;\d+)/(?P&lt;y&gt;[a-zA-Z]+)/$"</span>),</span><br><span class="line">    <span class="comment"># (?P&lt;name&gt;pattern) 正则分组</span></span><br><span class="line">    re_path(<span class="string">r"^(\d+)/([a-zA-Z]+)/$"</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>路由通过尖括号进行分组匹配，使用int以及str内置转换器将连接对应部分的值进行转换；并将匹配到的结果传递到视图函数对应的参数位置上；</p><p>访问：<code>http://127.0.0.1:8000/1/abc/</code></p><p>其中<code>1</code>将作为x的参数值，<code>abc</code>将作为y的参数</p><p>但如果访问连接是：<code>http://127.0.0.1:8000/abc/abc/</code>，这会匹配到第二个路由，第二个路由没有对传递参数的类型进行限定</p></blockquote><ul><li>内置Path转换器：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str：匹配除了路径分隔符（`/`）之外的非空字符串，这是默认的形式</span><br><span class="line">int：匹配正整数，包含<span class="number">0</span></span><br><span class="line">slug：匹配字母、数字以及横杠、下划线组成的字符串</span><br><span class="line">uuid：匹配格式化的uuid，如 <span class="number">075194</span>d3<span class="number">-6885</span><span class="number">-417</span>e-a8a8<span class="number">-6</span>c931e272f00</span><br><span class="line">path：匹配任何非空字符串，包含了路径分隔符</span><br></pre></td></tr></table></figure><h6 id="自定义转换器"><a href="#自定义转换器" class="headerlink" title="自定义转换器"></a>自定义转换器</h6><blockquote><p>除了以上<code>django</code>所提供的path转换器，如果还觉得无法实现我们想要的功能，我们可以通过编写一个类进行自定义<code>path</code>转换器</p></blockquote><ol><li><p>定义转换器类，类名随意</p></li><li><p>定义类中必须属性</p><blockquote><p><code>regex</code>：一个字符串形式的正则表达式，也是对应的路由规则</p><p><code>to_python(self, value)</code>：用于将匹配到的路由字符串转换为<code>Python</code>中的数据类型，并传递给视图函数，<strong>如果转换失败，必须抛出ValueError</strong>，路由映射视图函数时使用</p><p><code>to_url(self, value)</code>：将<code>Python</code>数据类型转换为一段url的方法，<code>to_python</code>方法的反向操作，反向解析时使用</p></blockquote></li><li><p>通过django.urls模块中的register_converter函数进行注册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数第一个参数为转换器类</span><br><span class="line">函数第二个参数为转换器别名</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>以下定义一个路由参数只能是三位字符的路由规则</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先将转换器类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeChar</span>:</span></span><br><span class="line">    regex = <span class="string">"[a-zA-Z]&#123;3&#125;"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_python</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        print(<span class="string">"to_python"</span>)</span><br><span class="line">        <span class="keyword">return</span> str(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_url</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        <span class="comment"># 当通过反向路由解析时，将会调用该函数</span></span><br><span class="line">        print(<span class="string">'to_url'</span>)</span><br><span class="line">        <span class="keyword">return</span> str(value)[:<span class="number">3</span>] </span><br><span class="line">    <span class="comment">#此处切片操作是为了当反向路由解析传参字符串长于3时，可以将其截断，符合转换器正则规则</span></span><br><span class="line"><span class="comment">#注册转换器</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> register_converter</span><br><span class="line">register_converter(ThreeChar,<span class="string">'tc'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'&lt;tc:x&gt;/&lt;tc:y&gt;/'</span>,views.index)</span><br><span class="line">]</span><br><span class="line"><span class="comment">#127.0.0.1:8000/aaa/bbb/</span></span><br></pre></td></tr></table></figure><blockquote><p>接下里，通过路由进行访问该视图映射时，一定是三个字符所组成的路由才可以，否则是访问不到的</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#urls.py</span></span><br><span class="line">app_name = <span class="string">"app"</span></span><br><span class="line">path(<span class="string">'&lt;tc:x&gt;/&lt;tc:y&gt;/'</span>,views.index, name=<span class="string">"threechr"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="keyword">return</span> redirect(reverse(<span class="string">"app:threechr"</span>,args=(<span class="string">'aaaa'</span>,<span class="string">'bbbb'</span>)))</span><br><span class="line"><span class="comment">#此时会调用three路由规则中的tc转换器中的to_url反向合成路由，并切片只取参数前三位</span></span><br></pre></td></tr></table></figure><h5 id="路由分发"><a href="#路由分发" class="headerlink" title="路由分发"></a>路由分发</h5><blockquote><p>我们的路由编写都是在项目主要目录下的<code>urls.py</code>文件中，但是如果<code>app</code>有很多的话，这么多路由都写到一起，明显是一件很不方便管理的事情</p><p>其实在之前的练习中，我们使用的方式均是路由分发，每个子<code>app</code>都拥有自己独立的<code>urls.py</code>路由映射文件，而主控路由文件里只需要使用<code>include</code>函数导入子<code>app</code>下路由文件即可，这就是路由分发</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">''</span>,include(<span class="string">"urlapp.urls"</span>)) <span class="comment"># 使用include 实现路由分发，找到子app下的路由文件</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>路由分发为我们带来的好处有很多，可以让我们在多个<code>app</code>的项目中更加方便有效的管理每一个路由</p><p>并且也可以让我们的用户在访问时看到浏览器中的<code>URL</code>地址更加<strong>赏心悦目</strong></p></blockquote><h5 id="路由反向解析"><a href="#路由反向解析" class="headerlink" title="路由反向解析"></a>路由反向解析</h5><blockquote><p>到了这里，思考一下，之前我们已经设置过了很多路由；</p><p>但是现在会出现一个问题，比如我们把其中某个路由规则进行了修改，把<code>aaa</code>换成了<code>aba</code>，那么现在我们需要回到每一个使用到这个路由的地方进行同步修改，这显然非常麻烦的，如果修改的路由更多，这甚至是一个灾难</p></blockquote><blockquote><p><code>django</code>也为我们提供了一个解决办法，通过为路由映射使用<code>name</code>参数，来为每一个路由映射设置一个独立唯一的变量名</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path(<span class="string">'left/&lt;str:x&gt;/'</span>,views.left, name=<span class="string">"left"</span>),</span><br><span class="line">path(<span class="string">'right/&lt;int:x&gt;/'</span>,views.right, name=<span class="string">"right"</span>),</span><br><span class="line"><span class="comment"># 通过正则命名分组方式</span></span><br><span class="line">re_path(<span class="string">r'^left/([a-zA-Z]+)/$'</span>,views.left,name=<span class="string">"left"</span>),</span><br><span class="line">re_path(<span class="string">r'^right/(?P&lt;x&gt;\d+)/$'</span>,views.right, name=<span class="string">"right"</span>)</span><br></pre></td></tr></table></figure><ul><li>两个视图函数对应如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left</span><span class="params">(request,x)</span>:</span></span><br><span class="line">    <span class="comment"># x: str</span></span><br><span class="line">    content = &#123;</span><br><span class="line">        <span class="string">'message'</span>:x,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">"left.html"</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">right</span><span class="params">(request,x)</span>:</span></span><br><span class="line">    <span class="comment"># x: int</span></span><br><span class="line">    content = &#123;</span><br><span class="line">        <span class="string">'message'</span>:x,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">"right.html"</span>,content)</span><br></pre></td></tr></table></figure><ul><li>两个HTML页面</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;我是左页面&lt;/p&gt;</span><br><span class="line">&lt;p&gt;路由参数: &#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;a href="&#123;% url 'right' 123 %&#125;"&gt;右页面&lt;/a&gt;</span><br><span class="line">&lt;!-- ------另一个页面------ --&gt;</span><br><span class="line">&lt;p&gt;我是右页面&lt;/p&gt;</span><br><span class="line">&lt;p&gt;路由参数: &#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;a href="&#123;% url 'left' 'abc' %&#125;"&gt;右页面&lt;/a&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在模板页面中，对于已命名路由可以通过 &#123;% url “name” “arg” %&#125;模板标签进行反向解析</p><p>参数以空格隔开，在标签后传入</p></blockquote><ul><li>视图函数反向解析</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> redirect(reverse(<span class="string">"left"</span>,args=(<span class="string">'aaa'</span>,) ))</span><br></pre></td></tr></table></figure><blockquote><p>在视图函数中需要使用到路由命名时，进行反向解析需要我们通过<code>django.shortcuts</code>模块下的<code>reverse</code>函数</p></blockquote><ul><li><code>reverse(viewname,args=None,kwargs=None)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参数介绍</span><br><span class="line">viewname：视图函数、命名路由映射、或视图函数路径的字符串</span><br><span class="line">args：元组形式路由传参。</span><br><span class="line">kwargs：字典形式路由传参</span><br></pre></td></tr></table></figure><h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><blockquote><p>如果想在多个<code>app</code>下使用相同的<code>name</code>路由命名，那么我们可以通过路由分发过程中的include函数来指定不同<code>app</code>所属的命名空间</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'app1/'</span>,include((<span class="string">"app1.urls"</span>,<span class="string">'app1'</span>))),</span><br><span class="line">    <span class="comment">#直接传递一个元祖，元祖第一个值为分发路由地址，第二个值为命名空间</span></span><br><span class="line">    path(<span class="string">'app2/'</span>,include((<span class="string">"app2.urls"</span>,<span class="string">'app2'</span>)))</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>当为每个<code>app</code>的路由分发映射设置了命名空间，接下来在模板页面以及视图函数对路由的反向解析将是如下所示的样子，路由解析前加冒号指明命名空间</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line"><span class="keyword">return</span> redirect(reverse(<span class="string">"app1:left"</span>))</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'app2:left' %&#125;"</span>&gt;</span>app2:left<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="应用命名空间：app-name"><a href="#应用命名空间：app-name" class="headerlink" title="应用命名空间：app_name"></a>应用命名空间：app_name</h6><blockquote><p>使用<code>app_name</code>指明命名空间，在子<code>app</code>的<code>urls.py</code>文件下配置全局变量<code>app_name</code>，这个值是唯一的</p><p>在这个路由文件中定义的其他映射关系，将具有命名空间<code>app1</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app_name = <span class="string">"app1"</span> <span class="comment"># 这个值应该是唯一的</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">   ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h6 id="实例命名空间：namespace"><a href="#实例命名空间：namespace" class="headerlink" title="实例命名空间：namespace"></a>实例命名空间：namespace</h6><blockquote><p>当有多个子<code>app</code>同时引入同一个子路由映射文件，比如这样</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'app1/'</span>,include(<span class="string">"app1.urls"</span>)),</span><br><span class="line">    path(<span class="string">'app2/'</span>,include(<span class="string">"app1.urls"</span>))</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>这就会出现一个问题，不同的路由访问在做路由反向解析时，会造成混淆，</p><p>此时需要给每一个路由分发的规则设置<code>namespace</code>属性，为实例进行命名空间</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'app1/'</span>,include(<span class="string">"app1.urls"</span>,namespace=<span class="string">"app1"</span>)),</span><br><span class="line">    path(<span class="string">'app2/'</span>,include(<span class="string">"app1.urls"</span>,namespace=<span class="string">"app2"</span>))</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>这样做的好处，可以在不同路由导向同一<code>app</code>下时，为他们的不同命名空间；</p><p>虽然看起来到最后执行的视图函数功能是一样的，但可以分清楚究竟是哪个路由引起视图函数在工作</p><p>接下来视图及模板页面中使用<code>namespace</code>的值</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是左页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>路由参数: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'app1:right' 123 %&#125;"</span>&gt;</span>app1的右页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是右页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>路由参数: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'app1:left' 'abc' %&#125;"</span>&gt;</span>app1的左页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ----------------------------------------- --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是左页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>路由参数: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'app2:right' 123 %&#125;"</span>&gt;</span>app2的右页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是右页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>路由参数: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'app2:left' 'abc' %&#125;"</span>&gt;</span>app2的左页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;路由层&quot;&gt;&lt;a href=&quot;#路由层&quot; class=&quot;headerlink&quot; title=&quot;路由层&quot;&gt;&lt;/a&gt;路由层&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;路由是Web服务的入口，就好像办事大厅有各个服务窗口一样&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化、云计算概念</title>
    <link href="http://yoursite.com/2030/12/30/%E8%99%9A%E6%8B%9F%E5%8C%96%E3%80%81%E4%BA%91%E8%AE%A1%E7%AE%97%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2030/12/30/虚拟化、云计算概念/</id>
    <published>2030-12-29T16:00:00.000Z</published>
    <updated>2019-12-26T02:00:02.406Z</updated>
    
    <content type="html"><![CDATA[<h3 id="虚拟化、云计算概念："><a href="#虚拟化、云计算概念：" class="headerlink" title="虚拟化、云计算概念："></a>虚拟化、云计算概念：</h3><p>美国环境保护署（EPA）报告的一组有趣的统计数据。</p><a id="more"></a><p>EPA研究服务器和数据中心的能源效率时发现，实际上服务器只有5%的时间在工作。在其他时间，服务器都处于 “休眠” 状态。就是说只有5%的消耗属于服务性能的消耗，其他都属于自己的无用消耗。</p><p>####什么是虚拟化：</p><p>虚拟化是指通过虚拟化技术奖一台计算机虚拟为多台逻辑计算机。在一台计算机上同时运行多个逻辑计算机，每个逻辑计算机可运行不同的操作系统，并且应用程序都可以在相互独立的空间运行而互不影响，从而显著提高计算机的工作效率。</p><p>虚拟化使用软件的方法重新定义划分IT资源，可以实现IT资源的鼎泰分配、灵活调度、跨域共享，提高IT资源利用率，使IT资源能够真正成为社会基础设施，服务于各行各业中灵活多变的应用需求。</p><h4 id="虚拟化技术的应用价值："><a href="#虚拟化技术的应用价值：" class="headerlink" title="虚拟化技术的应用价值："></a>虚拟化技术的应用价值：</h4><p><strong>虚拟化前</strong></p><p><img src="C:%5CUsers%5Clenovo%5CDesktop%5C1576409487(1).png" alt="1576409487(1)"></p><ul><li><p><strong>资源浪费</strong></p><p>系统资源的利用率不高，</p><p>有的服务器长期空闲，</p><p>有的服务器超负荷为运转</p></li><li><p><strong>管理难度大</strong>（设备多）</p><p>服务器、路由、防火墙等设备数量众多，管理难度大。</p></li><li><p><strong>重复劳动</strong></p><p>经常性的重装、重做系统，调试网络设备等</p></li><li><p><strong>参数配置繁琐</strong></p><p>调整单台服务器CPU内存、硬盘大小等流程繁琐</p></li><li><p><strong>安全性差</strong></p><p>每台主机一个独立的操作系统，当安装一个完整的LAMP环境时，apache和mysql的资源是共享的，会造成安全性的问题。当Apache爆发漏洞时，可能会导致mysql的数据泄露。</p></li></ul><p><strong>虚拟化后：</strong></p><ul><li><p><strong>高利用率</strong></p><p>将分散、独立的服务器资源整合成虚拟资源池后，资源利用率大大提高</p></li><li><p><strong>自由配置</strong></p><p>在资源池范围内，可以自行添加虚拟机，更改虚拟机内存、存储空间等参数</p></li><li><p><strong>统一管理</strong></p><p>通过虚拟化平台能够清晰的查看服务器运行情况、硬件健康状况等信息</p></li><li><p><strong>更稳定</strong></p><p>虚拟化本身就是一个安全技术，通过虚拟化技术手段，提高系统稳定性，保证数据安全</p></li></ul><h4 id="虚拟化过程："><a href="#虚拟化过程：" class="headerlink" title="虚拟化过程："></a>虚拟化过程：</h4><p>给每个服务器上装一个(VMware)虚拟卡，通过虚拟化软件把孤立的、分散的服务器资源连接在一起，形成一个虚拟化资源池，将资源集中起来，然后相对的虚拟出多台服务器，通过虚拟化软件将虚拟化任务自动的分配在多台服务器上</p><p><img src="C:%5CUsers%5Clenovo%5CDesktop%5C1576411355(1).png" alt="1576411355(1)"></p><h4 id="虚拟化技术的分类："><a href="#虚拟化技术的分类：" class="headerlink" title="虚拟化技术的分类："></a>虚拟化技术的分类：</h4><ul><li><p>全虚拟化技术</p><p>完全虚拟化技术又叫硬件辅助虚拟化技术，最初所使用的的虚拟化技术就是全虚拟化技术，它在虚拟机（VM）和硬件之间加了一个软件层——Hyperyisor，或者叫做虚拟机监控器（VMM）</p><ul><li>hypervisor（虚拟机软件层/虚拟机监控机）</li></ul><p><img src="C:%5CUsers%5Clenovo%5CDesktop%5C1576467239(1).png" alt="1576467239(1)"></p></li><li><p>半虚拟化技术/准虚拟化技术（使用比较少）</p><p>半虚拟化技术，也叫准虚拟化技术。它就是在全虚拟化的基础上，把客户操作系统进行了修改，增加了一个专门的API，这个API可以将客户操作系统发出的指令进行最优化，即不需要Hypervisor耗费一定的资源进行翻译操作，因此Hypervisor的工作负担变得非常的小，因此整体的性能也有很大的提高。</p></li></ul><p><img src="C:%5CUsers%5Clenovo%5CDesktop%5C1576467741(1).png" alt="1576467741(1)"></p><h4 id="openstack云计算概念："><a href="#openstack云计算概念：" class="headerlink" title="openstack云计算概念："></a>openstack云计算概念：</h4><p><strong>云计算</strong>就是通过网络访问服务的一种模式。</p><p><strong>“云计算”</strong>可以理解为：通过互联网可以使用足够强大的计算机为用户提供的服务，这种服务的使用像可以统一的单位来描述。</p><h4 id="虚拟化和云计算比较"><a href="#虚拟化和云计算比较" class="headerlink" title="虚拟化和云计算比较"></a>虚拟化和云计算比较</h4><p><strong>虚拟化：</strong> 是一种技术存在，从1个物理硬件系统创建多个模拟环境</p><p><strong>云计算：</strong> 是一种服务模式存在，汇聚并自动化分配虚拟资源以供按需使用</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;虚拟化、云计算概念：&quot;&gt;&lt;a href=&quot;#虚拟化、云计算概念：&quot; class=&quot;headerlink&quot; title=&quot;虚拟化、云计算概念：&quot;&gt;&lt;/a&gt;虚拟化、云计算概念：&lt;/h3&gt;&lt;p&gt;美国环境保护署（EPA）报告的一组有趣的统计数据。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Django初识</title>
    <link href="http://yoursite.com/2030/11/11/Django%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/2030/11/11/Django初识/</id>
    <published>2030-11-10T16:00:00.000Z</published>
    <updated>2019-12-26T01:58:25.772Z</updated>
    
    <content type="html"><![CDATA[<h4 id="开始玩耍Django"><a href="#开始玩耍Django" class="headerlink" title="开始玩耍Django"></a>开始玩耍Django</h4><blockquote><p><em>Django</em>是一个开放源代码的<code>Web</code>应用框架，由<code>Python</code>写成。采用了<code>MVT</code>的框架模式；最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是<code>CMS</code>（内容管理系统）软件</p><p>框架是以比利时的吉普赛爵士吉他手<code>Django Reinhardt</code>来命名的</p></blockquote><a id="more"></a><h5 id="django安装"><a href="#django安装" class="headerlink" title="django安装"></a>django安装</h5><blockquote><p><code>pip install django==2.0.4</code>(版本号)</p><p><code>pip install django</code>默认安装最新版本</p></blockquote><h5 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h5><blockquote><p><code>django-admin startproject myproject</code></p></blockquote><h5 id="开启开发服务器"><a href="#开启开发服务器" class="headerlink" title="开启开发服务器"></a>开启开发服务器</h5><blockquote><p><code>cd myproject</code>：进入项目目录</p><p><code>python manage.py runserver</code>：开启服务</p><p><code>python manage.py runserver 7000</code>：改变服务监听端口</p><p><code>python manage.py runserver 0:8000</code>：改变服务监听IP:端口</p></blockquote><h5 id="项目文件夹"><a href="#项目文件夹" class="headerlink" title="项目文件夹"></a>项目文件夹</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">manage.py：用来管理当前项目的一个命令行工具</span><br><span class="line">myproject/： 项目主文件夹</span><br><span class="line">myproject/__init__.py：空文件，用来指明当前的myproject为一个可导入的模块包</span><br><span class="line">myproject/settings.py：项目主要配置文件</span><br><span class="line">myproject/urls.py：项目主要路由配置文件</span><br><span class="line">myproject/wsgi.py：项目部署WSGI并发服务器时所需要的配置文件</span><br></pre></td></tr></table></figure><h5 id="Settings-py"><a href="#Settings-py" class="headerlink" title="Settings.py"></a>Settings.py</h5><blockquote><p>该文件是整个项目的主控文件，其中相关配置选项如下</p><p><code>https://docs.djangoproject.com/zh-hans/2.1/ref/settings/</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- BASE_DIR: 当前项目工作目录，用来在每一次开启项目时动态找到相关资源路径</span><br><span class="line">- SECRET_KEY: 加密的hash值以及保护某些签名数据的关键密钥</span><br><span class="line">- DEBUG: 调试模式</span><br><span class="line">- ALLOWED_HOSTS: 有哪些主机或域名可以访问当前django站点，如设置为*代表全部可访问。</span><br><span class="line">- INSTALL_APPS: django项目中所有使用的应用名称，自创建子应用也要加到这里，不然ORM数据库无法被识别到！</span><br><span class="line">- MIDDLEWARE: django中间件，用来在request或reponse过程中添加功能，比如确保安全性，传输保存Session等</span><br><span class="line">- SecurityMiddleware: xss脚本过滤，一些安全设置</span><br><span class="line">- SessionMiddleware: session支持中间件，在每次用户访问django项目时，添加session对每一个浏览器</span><br><span class="line">- CommonMiddleware: 通用组件，比如为路由添加末尾斜杠</span><br><span class="line">- CsrfViewMiddleware: 防跨站请求伪造令牌，为客户端添加csrf_token密钥，在表单提交时需提交该值</span><br><span class="line">- AuthenticationMiddleware: admin用户组件，每个request对象都会被添加admin下的user属性</span><br><span class="line">- MessageMiddleware: 消息中间件 展示一些后台消息给前端</span><br><span class="line">- XFrameOptionsMiddleware: 防止欺骗点击攻击出现；自身页面被嵌入到他人页面中，点击欺骗</span><br><span class="line">- ROOT_URLCONF: 主路由配置文件，字符串填写url.py文件路径</span><br><span class="line">- TEMPLATES: 模板文件配置项</span><br><span class="line">- WSGI_APPLICATION: WSGI服务器配置项，找到当前django下的wsgi引入APP文件</span><br><span class="line">- DATABASES: 数据库配置项，默认使用SQLite3，一个本地文件数据库</span><br><span class="line">- AUTH_PASSWORD_VALIDATORS: 检查用户密码强度的验证程序列表，不过是针对admin界面下的用户，而非自定义</span><br><span class="line">- LANGUAGE_CODE: django所使用语言文件</span><br><span class="line">- TIME_ZONE: django所使用时区</span><br><span class="line">- USE_I18N: 国际化支持 <span class="number">18</span>表示Internationalization这个单词首字母I和结尾字母N之间的字母有<span class="number">18</span>个</span><br><span class="line">- USE_L10N: 是localization的缩写形式，意即在l和n之间有<span class="number">10</span>个字母</span><br><span class="line">- USE_TZ:开启了Time Zone功能，则所有的存储和内部处理，包括<span class="keyword">print</span>显示的时间将是是UTC时间格式</span><br><span class="line">- STATIC_URL: URL访问静态资源时的路径</span><br></pre></td></tr></table></figure><h4 id="来搞个Hello-World"><a href="#来搞个Hello-World" class="headerlink" title="来搞个Hello World"></a>来搞个Hello World</h4><h5 id="django创建子应用"><a href="#django创建子应用" class="headerlink" title="django创建子应用"></a>django创建子应用</h5><blockquote><p>项目和应用有啥区别？</p><p>应用是一个专门做某件事的网络应用程序：比如博客系统，或者公共记录的数据库，或者简单的投票程序</p><p>项目则是一个网站使用的配置和应用的集合。项目可以包含很多个<code>app</code>应用，应用可以被很多个项目使用</p></blockquote><ul><li><p><code>python manage.py startapp myapp</code></p><blockquote><p>创建子应用</p></blockquote></li></ul><h5 id="app目录"><a href="#app目录" class="headerlink" title="app目录"></a>app目录</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- admin.py: app在admin注册展示时需要的文件</span><br><span class="line">- views.py: app的功能视图函数文件</span><br><span class="line">- models.py: app需要使用数据库时的文件</span><br><span class="line">- urls.py: 当使用include路由分发时，每个app应该有他自己的子路由文件，这个是默认没有创建好的</span><br></pre></td></tr></table></figure><h5 id="视图函数"><a href="#视图函数" class="headerlink" title="视图函数"></a>视图函数</h5><blockquote><p>打开<code>app</code>下的<code>views.py</code>文件</p><p><code>Web</code>访问起始就是通过一个<code>URL</code>连接地址访问到服务器上的一个函数</p><p>在<code>views.py</code>中我们通过编写函数的形式，接收用户请求的<code>request</code>并返回一个<code>response</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每一个视图函数都需要有一个必须参数 request,用来接收用户访问时的请求内容</span></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"&lt;h1&gt;Hello world&lt;/h1&gt;"</span>)</span><br></pre></td></tr></table></figure><ul><li><code>HttpResponse</code>函数用来向用户返回一个字符串</li></ul><h5 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h5><blockquote><p>创建好了一个可以在请求时返回<code>H1</code>标签的视图函数，但是现在通过浏览器还是访问不到</p><p>需要我们为这个<code>app</code>下的函数进行路由配置</p></blockquote><blockquote><p>第一种简单的路由配置，直接在主控路由文件下，找到这个视图函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myproject/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls), <span class="comment">#admin控制界面路由</span></span><br><span class="line">    path(<span class="string">''</span>,views.index) </span><br><span class="line">    <span class="comment">#path函数第一个参数为访问地址，空字符串代表：当用户直接访问首页时</span></span><br><span class="line">    <span class="comment">#第二个参数代表访问该地址时对应的视图函数，我们引入了app下的views中的index视图函数</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>接下来访问<code>127.0.0.1:8000</code>，那么你会看到一个非常大的<code>Hello world</code></li></ul><blockquote><p>以上将视图函数的查找直接写到主控路由并不是最好的办法</p><p>我们的项目通常会有非常多的路由配置项，如果都堆到这个文件中肯定是非常乱的，难以维护</p></blockquote><ul><li>我们可以在对应<code>app</code>下创建一个子路由控制文件，并在其中设置视图的路由配置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myapp/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">""</span>,views.index)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>现在虽然配置了<code>app</code>下的路由文件，但是访问时，是看不到对应视图的结果</p><p>这是因为默认的<code>url</code>查找动作将会从主控路由文件开始，我们还需要在主控路由文件下进行路由分发设置</p><p>让主控路由可以找到子<code>app</code>下的路由映射文件</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myproject/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    <span class="comment">#path('',views.index)</span></span><br><span class="line">    path(<span class="string">''</span>,include(<span class="string">"myapp.urls"</span>)),</span><br><span class="line">    <span class="comment"># 函数 include() 允许引用其它 URLconfs</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>接下来再次尝试，在浏览器中访问主机域名；如果可以看到的话，恭喜你，效果已经很棒了！</li></ul><h6 id="路由查找流程"><a href="#路由查找流程" class="headerlink" title="路由查找流程"></a>路由查找流程</h6><ol><li>查找主控路由文件下的<code>urlpatterns</code>全局变量，这是一个序列数据类型，其中每一个元素都是对应的一个路由匹配规则</li><li>如果在规则中查找到符合匹配规则的，则执行其中的对应执行函数</li><li>如果对应的不是一个执行函数，而是一个<code>include</code>路由包含，那么截断与此项匹配的<code>URL</code>的部分，并将剩余的路由字符串发送到<code>include</code>所包含的子路由文件中以供进一步处理</li><li>如果没有匹配到的任何结果，<code>django</code>默认抛出<code>Page not found (404)</code></li></ol><blockquote><p><strong>注意</strong>：<code>Django</code>的路由不考虑HTTP请求方式，仅根据<code>URL</code>进行路由，即，只要<code>URL</code>相同，无论<code>POST</code>、<code>GET</code>等哪种请求方式都指向同一个操作函数</p></blockquote><h6 id="path"><a href="#path" class="headerlink" title="path"></a>path</h6><blockquote><p><code>path</code>函数用来处理一个路由对应的视图映射</p></blockquote><ul><li><p><code>path(route, view, name)</code></p><blockquote><p><code>route</code>： 匹配规则，是一个字符串</p><p><code>view</code>：对应的视图函数</p><p><code>name</code>：未来我们会用到他，用来为匹配规则命名，这样方便日后修改路由而不影响全局下的路由使用</p></blockquote></li></ul><h6 id="re-path"><a href="#re-path" class="headerlink" title="re_path"></a>re_path</h6><blockquote><p><code>re_path</code>是<code>path</code>函数的加强版</p><p>可以在<code>re_path</code>函数的第一个位置的字符串参数，是一个标准<code>Python</code>正则表达式，其余参数与<code>path</code>相同</p></blockquote><blockquote><p><strong>注意</strong>：匹配模式的最开头不需要添加<code>/</code>，因为默认情况下，每个<code>url</code>都带一个最前面的<code>/</code>，既然大家都有的部分，就不用浪费时间特别写一个了，所以一定要注意在写路由映射关系时，记得加末尾的<code>/</code></p></blockquote><h5 id="模板页面"><a href="#模板页面" class="headerlink" title="模板页面"></a>模板页面</h5><blockquote><p>返回一个字符串这肯定是不行的，太<code>low</code>了，也不好看，现在来返回一个正式的<code>HTML</code>页面</p><p>并在<code>HTML</code>页面中加入模板变量，由视图函数动态传递值；</p></blockquote><ul><li>配置<code>django</code>中模板页面的保存路径，在项目目录下的<code>settings.py</code>文件中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myproject/settings.py</span></span><br><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django.template.backends.django.DjangoTemplates'</span>,</span><br><span class="line">        <span class="string">'DIRS'</span>: [os.path.join(BASE_DIR,<span class="string">'template'</span>)], <span class="comment"># 就是这一行 设置静态模板路径</span></span><br><span class="line">        <span class="string">'APP_DIRS'</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">'OPTIONS'</span>: &#123;</span><br><span class="line">            <span class="string">'context_processors'</span>: [</span><br><span class="line">                <span class="string">'django.template.context_processors.debug'</span>,</span><br><span class="line">                <span class="string">'django.template.context_processors.request'</span>,</span><br><span class="line">                <span class="string">'django.contrib.auth.context_processors.auth'</span>,</span><br><span class="line">                <span class="string">'django.contrib.messages.context_processors.messages'</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li><code>创建template</code>目录并在其中创建<code>index.html</code>文件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在<code>HTML</code>页面中，我们并没有明确指出<code>H1</code>标签的内容；通过一个``来等待接收视图函数传来的数据，在<code>HTML</code>页面中这样的变量也叫做<strong>模板变量</strong>，双大括号为使用语法</p></blockquote><ul><li>接下来修改之前的视图函数，由视图函数传递变量给到<code>HTML</code>页面</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myapp/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment">#return HttpResponse("&lt;h1&gt;Hello world&lt;/h1&gt;")</span></span><br><span class="line">    content = &#123;</span><br><span class="line">        <span class="string">"message"</span>:<span class="string">"你好，世界"</span> <span class="comment">#此处的key值message对应页面中我们写的&#123;&#123; message &#125;&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">'index.html'</span>,content)</span><br></pre></td></tr></table></figure><h6 id="render"><a href="#render" class="headerlink" title="render"></a>render</h6><blockquote><p>render函数用来返回一个模板页面，并将一个字典组合成的模板变量传递到模板页面上，完成页面的渲染</p></blockquote><ul><li><p><code>render(request, template_name, context=None)</code></p><blockquote><p>返回一个HTTP响应</p></blockquote><blockquote><p><code>request</code>： 固定接收<code>request</code>请求</p><p><code>template_name</code>： 为一个可以找到的模板页面</p><p><code>context</code>： 模板页面所需模板变量</p></blockquote></li></ul><h6 id="模板变量"><a href="#模板变量" class="headerlink" title="模板变量"></a>模板变量</h6><blockquote><p>在<code>django</code>中的<code>HTML</code>页面，不光可以编写原本的标签等内容，还可以像<code>Vue</code>一样在页面中使用双大括号，来提前定义一些模板变量，之后动态的渲染到<code>HTML</code>模板页面中</p></blockquote><blockquote><p>模板变量可以由后台视图函数构建一个<strong>字典数据类型</strong>传递，</p><p>字典的<code>key</code>是模板变量名，<code>value</code>值该模板变量对应的数据</p><p>当然，模板变量的内容远不止此，还会再后面继续为大家叙述</p></blockquote><h5 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h5><blockquote><p>虽然有了模板页面，可以来展示一些标签的效果，但是整个HTML还是感觉很丑陋</p><p>我们还要继续引入一些类似<code>css、img</code>这样的静态资源，来装饰我们的页面</p><p>在<code>django</code>中模板页面的静态资源使用，不能像之前写<code>HTML</code>代码直接引入</p><p>需要我们首先在项目中创建目录保存对应的静态资源，该目录名常为<code>static</code></p></blockquote><ul><li>在settings中配置静态文件保存目录，<strong>添加</strong>如下内容</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STATICFILES_DIRS = (</span><br><span class="line">    os.path.join(BASE_DIR, <span class="string">'static'</span>),</span><br><span class="line">)</span><br><span class="line"><span class="comment"># STATICFILES_DIRS 该配置项用来告诉django在查找静态资源时，应该访问哪个目录</span></span><br></pre></td></tr></table></figure><ul><li>在项目中创建<code>static</code>目录，<code>static</code>目录下创建专门保存图片的<code>img</code>目录，在里面存一张图片<code>1.jpg</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#此时的目录结构</span></span><br><span class="line">myproject/</span><br><span class="line">myproject/</span><br><span class="line">myapp/</span><br><span class="line">template/</span><br><span class="line">static/</span><br><span class="line">img/</span><br><span class="line"><span class="number">1.j</span>pg</span><br></pre></td></tr></table></figure><ul><li>有了图片，接下来在模板页面中去引入并使用它，打开<code>index.html</code>进行修</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    &#123;% load staticfiles %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'&#123;% static "img/1.jpg" %&#125;'</span> <span class="attr">alt</span>=<span class="string">"图片"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里用到了一个特殊语法：&#123;% tag %&#125;这个叫静态标签，静态标签不同于模板变量，静态标签经常用来加载数据，或创建逻辑，比如之后我们要学到的&#123;% if %&#125;，使用静态标签可以方便我们在模板页面上实现某些只有在后台代码中才可以实现的逻辑功能</p></blockquote><blockquote><p>在页面中要引入静态资源：图片，<code>CSS</code>，<code>JS</code>文件在引入时都需要通过&#123;% static “path” %&#125;来进行引入</p></blockquote><blockquote><p>最后，需要使用静态标签<code>static</code>前使用&#123;% load staticfiles %&#125;标签进行静态资源路径的加载</p></blockquote><h5 id="模型数据库"><a href="#模型数据库" class="headerlink" title="模型数据库"></a>模型数据库</h5><blockquote><p>有了以上内容的修饰，现在感觉还是缺少一些什么，我们在视图函数中为前端页面返回的是一个提前定义好的变量，这显然在真正开发中是很少出现的，我们的数据大都来自于数据库中，那么现在需要我们在项目中加入数据库，并且在视图函数中通过对数据库的访问来拿到数据</p></blockquote><ul><li>创建数据库，这里使用项目自带的<code>SQLite3</code>数据库，默认已经是配置好的，接下来需要我们进入到<code>app</code>下的<code>models.py</code>文件中，编写一个类，这个类就对应数据库中的一张表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myapp/models.py</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weather</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    weather = models.CharField(max_length=<span class="number">100</span>,verbose_name=<span class="string">"天气"</span>)</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        verbose_name_plural = <span class="string">"天气"</span></span><br><span class="line">        <span class="comment"># 设置当前表名的一个可读的性更好的名字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weather</span><br></pre></td></tr></table></figure><blockquote><p>在这里我们使用到了<code>django</code>的<code>orm</code>映射关系用来创建数据库表，继承自<code>django</code>的<code>models.Model</code>类，</p><p><strong>一个类用来表示一张表，类中的一个属性代表一个字段，</strong></p></blockquote><blockquote><p>这里我们定义了一个类型为<code>CharField</code>，长度为<code>100</code>的字段，用来存储天气</p><p><code>models.CharField(max_length=100,verbose_name=&quot;天气&quot;)</code></p></blockquote><hr><blockquote><p>下面的<code>class Meta</code>是模型类的元类，用来设置当前表的一些属性；</p><p>这里我们使用<code>verbose_name_plural</code>属性设置当前表在<code>admin</code>后台查看时的名字</p></blockquote><blockquote><p>在这里我们还定义了一个属于实例的函数<code>__str__</code>，用来描述当前数据在返回时的默认展示结果，为<code>weather</code>字段的值</p></blockquote><blockquote><p><code>django</code>在创建模型类对应的数据表时，默认使用 <code>应用名</code>加<code>下划线</code>加<code>模型类名</code>作为表的名字；比如当前<code>Weather</code>表名为：<code>myapp_Weather</code></p></blockquote><blockquote><p><code>orm</code>映射关系，是<code>django</code>与数据库之间的一个桥梁，可以使开发者不再关注如何去编写<code>SQL</code>语句，直接通过一套<code>ORM</code>所提供的<code>API</code>接口即可方便对各种数据库进行交互</p></blockquote><ul><li>当某个子应用<code>APP</code>涉及到了数据库的使用时，要记得在<code>settings</code>文件中进行配置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myproject/settings.py</span></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,</span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,</span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,</span><br><span class="line">    <span class="string">'myapp'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>接下来通过<code>manage.py</code>命令行管理工具提供的两条，创建我们所需要的数据</li></ul><blockquote><p><strong>注意</strong>：默认<code>django</code>本身就已经需要一些数据的创建，所以我们在初次执行以下两条命令时可能会看到很多数据表和字段的创建，不要惊讶，这是正常的</p></blockquote><blockquote><p><code>python manage.py migrate</code>：根据数据库迁移文件生成对应<code>SQL</code>语句并执行</p><p>初次执行是为了先把默认django需要的数据库创建出来</p></blockquote><blockquote><p><code>python manage.py makemigrations</code>：创建数据库迁移文件</p><p>这次执行是为了创建APP中Weather模型类的迁移文件</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; python manage.py migrate</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>将新添加的模型类迁移文件生成对应<code>SQL</code>，实际创建出对应的<code>Weather</code>表</p></blockquote><ul><li>如果提示结果正常，那么代表相应的数据表已经创建好了，接下来就需要我们去到<code>django</code>为我们提供的<code>admin</code>（数据库管理界面）来进行相关表的操作了！</li></ul><h5 id="admin控制台"><a href="#admin控制台" class="headerlink" title="admin控制台"></a>admin控制台</h5><blockquote><p><code>admin</code>控制台是<code>django</code>为我们提供的一个非常便捷的用来管理数据库的界面</p><p>在主控路由文件下，其实你已经看到了它对应的路由设置：<code>path(&#39;admin/&#39;, admin.site.urls),</code></p></blockquote><blockquote><p>进入<code>admin</code>界面，初次访问连接：<code>127.0.0.1/admin</code>，会提示我们输入账号密码，这是因为<code>django</code>的<code>admin</code>界面是需要一个超级管理员来登陆访问的，所以还需要我们创建对应的<code>admin</code>界面下的超级用户</p></blockquote><ul><li>创建<code>admin</code>超级用户，使用<code>manage.py</code>命令行工具执行如下命令</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Username (leave blank to use <span class="string">'lienze'</span>): root</span><br><span class="line">Email address:</span><br><span class="line">Password:</span><br><span class="line">Password (again):</span><br><span class="line">This password <span class="keyword">is</span> too short. It must contain at least <span class="number">8</span> characters.</span><br><span class="line">This password <span class="keyword">is</span> too common.</span><br><span class="line">This password <span class="keyword">is</span> entirely numeric.</span><br><span class="line">Password:</span><br><span class="line">Password (again):</span><br><span class="line">This password <span class="keyword">is</span> too common.</span><br><span class="line">This password <span class="keyword">is</span> entirely numeric.</span><br><span class="line">Password:</span><br><span class="line">Password (again):</span><br><span class="line">Superuser created successfully.</span><br></pre></td></tr></table></figure><blockquote><p>以上是我们创建超级用户的过程，非常坎坷；</p><p>可以看到，在输入太短（不满足8位），或是只包含数字的简单密码，超级用户的创建都是被拒绝的</p><p>所以我们把用户账号创建为<code>root</code>，而密码创建为<code>a1234567</code>，</p></blockquote><ul><li>接下来开启测试服务器，并通过创建好的超级用户登陆访问，如果幸运的话，你已经可以看到后台的<code>admin</code>界面啦</li></ul><blockquote><p><code>admin</code>界面已经展示出了默认<code>django</code>所使用的两张表，用户表和组表，用来保存当前管理后台的用户以及对应权限分组，可以点入用户表查看其中我们刚创建的<code>root</code>。</p></blockquote><h5 id="admin注册表"><a href="#admin注册表" class="headerlink" title="admin注册表"></a>admin注册表</h5><blockquote><p>问题还是有的，虽然<code>admin</code>界面已经可以登入，但是为什么看不到刚才创建的<code>Weather</code>表呢</p><p>这是因为默认的表创建之后，还需要通过对应app下的<code>admin.py</code>文件进行<code>admin</code>后台注册，只有注册在这个文件中的模型类对应的表才可以在<code>admin</code>界面所看到</p></blockquote><ul><li>在app下的admin.py文件中进行模型类的注册</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myapp/admin.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line">admin.site.register(models.Weather)</span><br><span class="line"><span class="comment">#使用register函数接收模型类作为参数即可完成注册</span></span><br></pre></td></tr></table></figure><blockquote><p>注册成功之后，在服务器，通过浏览器访问<code>admin</code>界面，就可以看到创建好的<code>Weather</code>表了</p></blockquote><ul><li>鼠标点击进去之后，就可以看到对应的表数据界面；右上角提供了可以添加功能的选项，试试给这个表来一些数据吧，这里我们添加了三条数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">阴天，晴天，打雷了</span><br></pre></td></tr></table></figure><h5 id="视图操作模型"><a href="#视图操作模型" class="headerlink" title="视图操作模型"></a>视图操作模型</h5><blockquote><p>最终我们希望可以在视图函数中通过<code>orm</code>接口来访问到表中的数据，那么来打开视图文件吧：<code>views.py</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myapp/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> models</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    </span><br><span class="line">    weathers = models.Weather.objects.all()</span><br><span class="line">    content = &#123;</span><br><span class="line">        <span class="string">"weathers"</span>:weathers,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'index.html'</span>, content)</span><br></pre></td></tr></table></figure><ul><li>光返回是不行的，虽然我们绑定到了模板版变量的字典中，但是还得修改一下对应的要渲染的<code>HTML</code>页面哦：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    &#123;% load staticfiles %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;% for weather in weathers %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; weather &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% empty %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>没有任何天气<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>模板标签&#123;% for xxx in xxxs %&#125;可以用来在模板页面出迭代访问取出每一个数据</p><p>具体对于不同序列数据的访问我们会在后面详细为大家介绍</p><p>&#123;% empty %&#125;标签用来判断当循环访问数据为空时要做的事情，最后循环标签要有&#123;% endfor %&#125;标签进行结束；因为<code>HTML</code>中并没有像<code>Python</code>缩进这样的方式来控制代码块。</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>至此，我们的<code>HELLO WORLD</code>项目已经涵盖了<code>django</code>框架中的大部分常用的组件；</p><p><strong>路由</strong>、<strong>视图</strong>、<strong>模板</strong>、<strong>静态</strong>、<strong>模型</strong>，<strong>admin</strong></p><p>那么其中每一部分都还有很多内容等着我们去了解！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;开始玩耍Django&quot;&gt;&lt;a href=&quot;#开始玩耍Django&quot; class=&quot;headerlink&quot; title=&quot;开始玩耍Django&quot;&gt;&lt;/a&gt;开始玩耍Django&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Django&lt;/em&gt;是一个开放源代码的&lt;code&gt;Web&lt;/code&gt;应用框架，由&lt;code&gt;Python&lt;/code&gt;写成。采用了&lt;code&gt;MVT&lt;/code&gt;的框架模式；最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是&lt;code&gt;CMS&lt;/code&gt;（内容管理系统）软件&lt;/p&gt;
&lt;p&gt;框架是以比利时的吉普赛爵士吉他手&lt;code&gt;Django Reinhardt&lt;/code&gt;来命名的&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>二进制转十进制，十进制转二进制</title>
    <link href="http://yoursite.com/2030/11/05/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6%EF%BC%8C%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    <id>http://yoursite.com/2030/11/05/二进制转十进制，十进制转二进制/</id>
    <published>2030-11-04T16:00:00.000Z</published>
    <updated>2019-12-26T01:59:40.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二进制介绍"><a href="#二进制介绍" class="headerlink" title="二进制介绍"></a>二进制介绍</h2><blockquote><p>二进制是计算技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为，进位规则是“逢二进一”，借位规则是“借一当二”，由18世纪德国数理哲学大师莱布尼兹发现。当前的计算机系统使用的基本上是二进制系统，数据在计算机中主要是以补码的形式存储的。计算机中的二进制则是一个非常微小的开关，用“开”来表示1，“关”来表示0。<br>20世纪被称作第三次科技革命的重要标志之一的计算机的发明与应用，因为数字计算机只能识别和处理由‘0’.‘1’符号串组成的代码。其运算模式正是二进制。19世纪爱尔兰逻辑学家乔治布尔对逻辑命题的思考过程转化为对符号”0’’.’’1’’的某种代数演算，二进制是逢2进位的进位制。0、1是基本算符。因为它只使用0、1两个数字符号，非常简单方便，易于用电子方式实现。</p></blockquote><a id="more"></a><h2 id="十进制介绍"><a href="#十进制介绍" class="headerlink" title="十进制介绍"></a>十进制介绍</h2><blockquote><p>十进制：600，3/5，-7.99……看着这些耳熟能详的数字，你有没有想太多呢？其实这都是全世界通用的十进制，即1.满十进一，满二十进二，以此类推……2.按权展开，第一位权为10^0，第二位10^1……以此类推，第N位10^（N-1），该数的数值等于每位位的数值*该位对应的权值之和。</p></blockquote><h3 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h3><blockquote><p>十进制转二进制：十进制数转换为二进制数时，由于整数和小数的转换方法不同，所以先将十进制数的整数部分和小数部分分别转换后，再加以合并。<br>下面就是方法，挺简单的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用15除以2，商为7，余数为1，</span><br><span class="line">再用7除以2，商为3，余数为1，</span><br><span class="line">再用3除以2，商为1，余数为1，</span><br><span class="line">再用1除以2，商为0，余数为1，</span><br><span class="line">最后吧余数倒过来排列就为二进制的1111（即商为0时的1，商为1时的1，商为3时的1，商为7时的1）</span><br></pre></td></tr></table></figure><h3 id="二进制转十进制"><a href="#二进制转十进制" class="headerlink" title="二进制转十进制"></a>二进制转十进制</h3><blockquote><p>以二进制的1111转十进制为例：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">把二进制的1111看成是十进制的1111即1*10^3 + 1*10^2 + 1*10^1 + 1</span><br><span class="line">然后把10变成2，即1*2^3 + 1*2^2 + 1*2^1 + 1=15</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二进制介绍&quot;&gt;&lt;a href=&quot;#二进制介绍&quot; class=&quot;headerlink&quot; title=&quot;二进制介绍&quot;&gt;&lt;/a&gt;二进制介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;二进制是计算技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为，进位规则是“逢二进一”，借位规则是“借一当二”，由18世纪德国数理哲学大师莱布尼兹发现。当前的计算机系统使用的基本上是二进制系统，数据在计算机中主要是以补码的形式存储的。计算机中的二进制则是一个非常微小的开关，用“开”来表示1，“关”来表示0。&lt;br&gt;20世纪被称作第三次科技革命的重要标志之一的计算机的发明与应用，因为数字计算机只能识别和处理由‘0’.‘1’符号串组成的代码。其运算模式正是二进制。19世纪爱尔兰逻辑学家乔治布尔对逻辑命题的思考过程转化为对符号”0’’.’’1’’的某种代数演算，二进制是逢2进位的进位制。0、1是基本算符。因为它只使用0、1两个数字符号，非常简单方便，易于用电子方式实现。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="进制转换" scheme="http://yoursite.com/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix 监控系统</title>
    <link href="http://yoursite.com/2030/10/30/Zabbix%20%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2030/10/30/Zabbix 监控系统/</id>
    <published>2030-10-29T16:00:00.000Z</published>
    <updated>2019-12-27T09:11:43.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Zabbix-监控系统"><a href="#Zabbix-监控系统" class="headerlink" title="Zabbix 监控系统"></a>Zabbix 监控系统</h2><h4 id="什么是监控系统？"><a href="#什么是监控系统？" class="headerlink" title="什么是监控系统？"></a>什么是监控系统？</h4><a id="more"></a><p>例如：开车时的行车记录仪、班级里面的监控摄像头、医院使用的血压监测仪等等</p><p>在IT领域中，监控系统就是<strong>监控系统资源以及性能的硬件或者软件</strong></p><p><strong>监控软件</strong></p><ol><li>单一监控程序<ol><li>windows系统的任务管理</li><li>linux系统中的top、vmstat、iostat</li></ol></li><li>分布式监控程序</li></ol><h4 id="为什么需要监控系统？"><a href="#为什么需要监控系统？" class="headerlink" title="为什么需要监控系统？"></a>为什么需要监控系统？</h4><p>为用户提供稳定、高效、安全的服务</p><p>但是像zabbix和open-falcon只能监控某些方面。而为了业务高效运行还需要和APM也就是应用性能监控、全局链路调用追踪等一起实现。而安全性需要安全团队和相关系统紧密结合才行</p><h4 id="监控系统都有哪些功能？"><a href="#监控系统都有哪些功能？" class="headerlink" title="监控系统都有哪些功能？"></a>监控系统都有哪些功能？</h4><ol><li><strong>数据收集.</strong></li><li><strong>数据展示</strong></li><li><strong>告警策略</strong></li><li><strong>告警发送</strong></li><li><strong>事件管理</strong></li><li><strong>报表管理.</strong></li><li><strong>认证权限.</strong></li></ol><h4 id="开源监控系统现状"><a href="#开源监控系统现状" class="headerlink" title="开源监控系统现状"></a>开源监控系统现状</h4><ol><li>Nagios.<ul><li>1999年发布的初始版本。它可以监控网络、主机等设备。支持丰富的监控插件。用户可以根据自己的实际环境定义监控</li></ul></li><li>Cacti.<ul><li>2001年发布的。是一套基于<code>SNMP</code>和<code>RRDTool</code>的网络流量监控分析的系统</li><li><strong>RRDTool</strong>: 用来处理时间序列数据的套件</li><li><strong>SNMP</strong>: 简单网络管理协议</li></ul></li><li>Ganglia</li><li>Zabbix</li><li>Prometheus</li><li>Falcon</li><li>Grafana<ul><li>Grafana是可以美观的展示和分析监控数据的工具，收集数据并支持告警等功能</li></ul></li><li>Zenoss</li><li>Graphite</li><li>Open-falcon …<ul><li>小米公司开源的，高可用、可扩扎的开源监控解决方案</li></ul></li></ol><h4 id="监控系统可以干什么？"><a href="#监控系统可以干什么？" class="headerlink" title="监控系统可以干什么？"></a>监控系统可以干什么？</h4><ol><li>KPI聚类</li><li>瓶颈分析</li><li>KPI异常检测、定位</li><li>故障预测</li><li>容量预估</li></ol><h4 id="Zabbix-简介"><a href="#Zabbix-简介" class="headerlink" title="Zabbix 简介"></a>Zabbix 简介</h4><blockquote><p>市场上还有一款叫做<code>open-falcon</code>和zabbix类似，而且市场上也是在广泛使用，都是属于<strong>分布式监控程序</strong></p></blockquote><blockquote><p><strong>zabbix</strong> 是一个基于web界面的提供分布式系统监控的企业级的开源解决方案。</p></blockquote><blockquote><p><strong>zabbix</strong> 能监视各种网络参数， 保证服务器系统的安全稳定的运行，并提供灵活的通知机制以让SA快速定位并解决存在的各种问题。</p></blockquote><h5 id="了解zabbix"><a href="#了解zabbix" class="headerlink" title="了解zabbix"></a>了解zabbix</h5><p>我们通过zabbix能够监控到哪些硬件资源呢？理论上说，只要是与我饿们的业务相关的硬件资源，又应该被监控。比如主机、交换机、路由器、UPS等等。但是，监控她们的额前提是能与他们进行通讯，那么问题来了，由于硬件不同，导致我们无法使用统一的方法去监控他们，这个时候就需要监控程序有一定的通用性，或者说，监控程序需要能够与多种硬件设备通讯，才能满足我们的监控需求。所以zabbix如果想要能够全面的监控这些对象，则需要能够通过各种方法与他们通讯。</p><h5 id="Zabbix-的优点"><a href="#Zabbix-的优点" class="headerlink" title="Zabbix 的优点"></a>Zabbix 的优点</h5><ol><li>支持自动发现服务器和网络设置</li><li>支持底层自动发现</li><li>分布式的监控体系和集中式的web管理</li><li>支持主动监控和被动监控模式</li><li>服务器支持多种操作系统：<ol><li>linux</li><li>solaris</li><li>HP-UX</li><li>AIX</li><li>FreeBSD</li><li>OpenBSD</li><li>MAC …</li></ol></li><li><code>Agent客户端</code>支持多种操作系统：<ol><li>linux</li><li>Solaris</li><li>HP-UX</li><li>AIX</li><li>FreeBSD</li><li>Windows …</li></ol></li><li>基于SNMP、IPMI接口方式也可以 监控Agent</li><li>安全的用户认证及权限配置</li><li>基于WEB的管理方法，支持自由的自定义事件和邮件发送</li><li>高水平的业务视图监控资源，支持日志审计、资产管理等功能</li><li>支持高水平API二次开发、脚本监控、自Key定义、自动化运维整合调用</li></ol><h5 id="Zabbix-监控组件及流程"><a href="#Zabbix-监控组件及流程" class="headerlink" title="Zabbix 监控组件及流程"></a>Zabbix 监控组件及流程</h5><p>zabbix 主要有三大组件组成，分别是</p><ol><li><p><strong>Zabbix server端</strong></p><ol><li><code>Zabbix WEB GUI</code></li><li><code>Zabbix Datebase</code></li><li><code>Zabbix Server</code></li></ol></li></ol><ol start="2"><li><p><strong>Zabbix Proxy端</strong></p></li><li><p><strong>Zabbix Agent端</strong></p></li></ol><h5 id="zabbix的好处："><a href="#zabbix的好处：" class="headerlink" title="zabbix的好处："></a>zabbix的好处：</h5><p>占用资源少、可以获取CPU、内存、网卡、磁盘、日志等信息。</p><p>对于无法安装客户端的设备，zabbix支持通过<code>SNMP</code>获取监控数据</p><p>zabbix支持通过<code>IPMI</code>(智能平台管理接口)获取硬件的温度、风扇、硬盘、电源等</p><p>#####zabbix监控系统的意义</p><p>通过这些监控系统我们可以了解设备的繁忙程度、是否有异常的进程占用资源</p><p>比较常见的是：通过传感器获取设备的监控信息</p><h5 id="Zabbix-能监控哪些硬件资源呢？"><a href="#Zabbix-能监控哪些硬件资源呢？" class="headerlink" title="Zabbix 能监控哪些硬件资源呢？"></a>Zabbix 能监控哪些硬件资源呢？</h5><blockquote><p>如果理论上说，只要与我们业务相关的硬件资源，都可以被监控。例如：主机、交换机、路由器等等。但是监控的前提是能与他们进行通讯</p></blockquote><h5 id="Zabbix-支持哪些通讯方式呢？"><a href="#Zabbix-支持哪些通讯方式呢？" class="headerlink" title="Zabbix 支持哪些通讯方式呢？"></a>Zabbix 支持哪些通讯方式呢？</h5><ol><li><strong>Agent</strong>：通过专用的代理程序进行监控，与常见的master/agent模型类似。如果被监控对象支持对应的agent，推荐首选这种方式</li><li><strong>ssh/tenet</strong>：通过远程控制协议进行通讯，比如ssh或telnet</li><li><strong>SNMP</strong>:通过SNMP协议与被监控对象进行通讯，<code>SNMP</code>协议全称 Simple Network Mnaagement Protocol,被译为“简单网络管理协议”，通常来说，我们无法在路由器、交换机这种硬件上安装agent，但是这些硬件往往都支持SNMP协议、SNMP是一种比较久远的、通行的协议，大部分网络设备都支持这种协议，其实SNMP协议的工作方式也可以理解为master/agent的工作方式，只不过实在这些设备中内置了SNMP的agent而已，所以大部分网络设备都支持这种协议</li><li><strong>IPMI</strong>：通过IPMI接口进行监控，我们可以通过标准的IPMI硬件接口，监控被监控对象的物理特征，比如电压、温度、风扇状态、电源状态等等</li><li><strong>JMX</strong>：通过JMX进行监控，JMX全称 Java Management Extensions ，也就是Java管理扩展，监控JVM虚拟机时，使用这种方法也是非常不错的选择</li></ol><h5 id="Zabbix-监控流程"><a href="#Zabbix-监控流程" class="headerlink" title="Zabbix 监控流程"></a>Zabbix 监控流程</h5><h6 id="zabbix-核心组件"><a href="#zabbix-核心组件" class="headerlink" title="zabbix 核心组件"></a>zabbix 核心组件</h6><ul><li><strong>zabbix agent</strong>：部署在被监控主机上，负责被监控主机的数据，并将数据发送给zabbix server</li><li><strong>zabbix server</strong>：负责接收agent发送的报告信息，并且负责组织配置信息，统计信息，操作数据等</li><li><strong>zabbix database</strong>：用于储存所有zabbix的配置信息、监控数据的数据库</li><li><strong>zabbix web</strong>：zabbix的web界面，管理员通过web界面管理zabbix配置以及查看zabbix相关监控信息</li><li><strong>zabbix proxy</strong>：可选组件，用于分布式监控环境中，zabbix proxy代表server端，完成局部区域内的信息收集，最终统一发往server端</li></ul><ul><li>我们将zabbix agent 部署到被监控主机上，由agent采集数据，报告给负责控制中心主机，中心主机也就是master/agent模型中的master，负责监控的中心主机被称为zabbix serevr，zabbix server将从agent端接收到信息储存于zabbix的数据库中，我们把zabbix的数据库端称为zabbix database，如果管理员需要查看各种监控信息，则需要zabbix的GUI，zabbix的GUI是一种Web GUI，我们称之为zabbix web，zabbix web是使用PHP编写的，所以，如果想要使用zabbix web展示相关监控信息，需要依赖LAMP环境，不管 是zabbix server，或是zabbix web，他们都需要连接到zabbix database获取相关数据</li></ul><ul><li>当监控规模变得庞大时，我们可能有成千上万台设备需要监控，这时我们是否需要部署多套zabbix系统进行监控呢？如果部署多套zabbix监控系统。那么监控压力就会被分摊，但是，把这些监控的对象将会被尽量平均的分配到不同的监控系统中，这个时候，我们就无法通过统一的监控入口，去监控这些对象了。虽然分摊了监控压力，但是也增加了监控工作的复杂度？其实，zabbix天生就有处理这种问题的能力，因为zabbix支持这种分布式监控，我们可以把成千上万台的监控对象分成不同的区域，每个区域中设置一台代理主机，区域内的每个监控对象的信息被agent采集，提交给代理 主机，在这个区域内，代理主机的作用就好比zabbix server，我们称为这些代理主机为zabbix proxy，zabbix proxy再将收集到的信息统一提交给真正的zabbix server处理。这样，zabbix proxy不仅分摊了zabbix server的压力，同时，我们还能够通过统一的监控入口，监控所有的对象</li></ul><h5 id="zabbix-工作模式"><a href="#zabbix-工作模式" class="headerlink" title="zabbix 工作模式"></a>zabbix 工作模式</h5><blockquote><p> 我们都知道，agent端采集完数据主动发送给server端，这种模式我饿称之为<strong>主动模式</strong>，也就说对于agent端来说是主动的。</p></blockquote><blockquote><p>其实，agent端也可以不主动发送数据，而是等待server过来拉取数据，这种模式我们叫<strong>被动模式</strong></p></blockquote><blockquote><p>其实不管是主动模式还是被动模式，都是对于agent端来说的。而且，主动模式与被动模式可以同时存在，并不冲突。</p><p>管理员可以在agent端使用一个名为<code>zabbix_sender</code>的工具，测试是否能够从server端发送数据。</p><p>管理员也可以在server端使用一个名为<code>zabbix_get</code>的工具，测试是否能从agent端拉取数据</p></blockquote><h4 id="Zabbix-服务器搭建部署"><a href="#Zabbix-服务器搭建部署" class="headerlink" title="Zabbix 服务器搭建部署"></a>Zabbix 服务器搭建部署</h4><h5 id="安装描述"><a href="#安装描述" class="headerlink" title="安装描述"></a>安装描述</h5><p>简单地概念刚刚已经描述过，zabbix的几个常用的重要组件，在安装zabbix时，其实是在安装这些组件。</p><p>由于我们的监控规模也不大，所以此处将不会安装zabbix proxy ，我们需要安装如下组件：</p><ol><li><strong>Zabbix server</strong></li><li><strong>Zabbix database</strong></li><li><strong>Zabbix web</strong></li><li><strong>Zabbix agent</strong></li></ol><p>好了，接下来一个一个聊</p><p>安装的<code>zabbix server</code>版本为<code>3.0</code></p><p>因为zabbix3.X依赖的php版本 不能低于php5.4，而在centos6.8中，php默认版本为5.3</p><p>如果你想要使用centos6.X的操作系统。同时想要更加方便的升级php，可以使用Remi源升级PHP，</p><p>但是为了更加方便的使用yum源安装相关软件包，此处使用centos7安装<code>zabbix3.0.7</code></p><h5 id="安装-zabbix-server"><a href="#安装-zabbix-server" class="headerlink" title="安装 zabbix server"></a>安装 zabbix server</h5><p>为了方便安装，配置zabbix的官方yum源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://repo.zabbix.com/</span><br></pre></td></tr></table></figure><p>我们配置一下zabbix3.0的yum源</p><p><img src="/images/1577188749508.jpg" alt="1-1" title="本博客的主人最帅"></p><p>首先进入<code>/ect/yum.repo.d/</code>文件夹</p><p>查看一下 是否有<code>zabbix.repo</code>，如果没有创建一个并编写，如下图格式</p><p><img src="/images/1577189089487.jpg" alt="1-2" title="本博客的主人最帅"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zabbix]</span><br><span class="line">name=zabbix</span><br><span class="line">baseurl=http://repo.zabbix.com/zabbix/3.0/rhel/7/x86_64/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure><p>同时，我们配置了<strong>base</strong>源与<strong>epel</strong>源，因为安装过程中会用到这些yum源。</p><p>没有配置好的话，会报出如下图的错：</p><p><img src="/images/1577235080635.jpg" alt="1-3" title="本博客的主人最帅"></p><p>所以在下载之前，先配置好base源和epel源</p><p>这里选择的是redhat7下x86_64的zabbix3.0版本的包。但是安装zabbix-server-mysql时报错，原因是缺少libiksemel.so.3()(64bit)和fping包。这是因为yum安装zabbix不仅需要配置zabbix包源，还需要配置好epel源和base源，base源我们有自带就不用说了。</p><p>这时我们需要配置epel源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install epel-release</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /etc/yum.repo.d/</span><br></pre></td></tr></table></figure><p>这里看到多了epel.repo这个文件，表明epel配置成功。</p><p>然后我们继续安装zabbix-server-mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum -y install zabbix-server-mysql</span><br><span class="line"></span><br><span class="line">错误：软件包：zabbix-server-mysql-3.0.25-1.el7.x86_64 (zabbix)</span><br><span class="line">需要：libiksemel.so.3()(64bit)</span><br></pre></td></tr></table></figure><p>我们发现这里还有缺少依赖包libiksemel.so.3()(64bit)的问题。</p><p>我们通过下载zabbix源来解决这个问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install http://repo.zabbix.com/zabbix/3.0/rhel/7/x86_64/zabbix-release-3.0-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><p>最后安装zabbix-server-mysql成功 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum -y install zabbix-server-mysql zabbix-get --skip-broken</span><br><span class="line"></span><br><span class="line">已安装:</span><br><span class="line">zabbix-server-mysql.x86_64 0:3.0.25-1.el7</span><br></pre></td></tr></table></figure><p>准备工作完毕，剩下的就是安装各个组件了，我们一个一个安装</p><p>先安装<strong>zabbix server</strong></p><p>由于我们使用mysql作为数据库，所以，在安装zabbix3.X的版本的server端时，需要安装zabbix-server-mysql包，在3.X的zabbix版本中，并没有单独的zabbix server端程序包，安装zabbix-server-mysql包即为了安装了server端包，同时，我们可以在服务器安装zabbix_get包，以便想agent端发起测试采集数据请求，所以，我们在server端安装如下;</p><p><img src="/images/1577189265125.jpg" alt="1-4" title="本博客的主人最帅"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install zabbix-server-mysql zabbix-get</span><br></pre></td></tr></table></figure><p>在安装的时候，我遇到了一个问题，</p><p>密密麻麻的英文很头疼，而且好多都不认识咋办？其实也不用全都理解，全都认识，认识关键字就行。例如：You could try using –skip-broken to work around the problem ，大概意思就是 ‘你可以使用 “–skip-broken” 来解决这个问题‘，所以只需要在代码后面加上就可以了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install zabbix-server-mysql zabbix-get --skip-broken</span><br></pre></td></tr></table></figure><p>还有一种解决办法，就是更新一下你的yum，因为你的yum版本低了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y update</span><br></pre></td></tr></table></figure><p>安装完成后，输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql zabbix-server-mysql</span><br></pre></td></tr></table></figure><p>如果出现下图这样的情况，那就是你安装失败了。需要重新安装</p><p><img src="/images/1577235250247.jpg" alt="1-5" title="本博客的主人最帅"></p><p><img src="/images/1577235296648.jpg" alt="1-6" title="本博客的主人最帅"></p><p>重新安装还有可能碰到一种问题，</p><p>连上你同桌的WiFi就好了，因为你的网络丝毫不给你一分薄面！</p><p>之后重新下载一下就好了，出现Comlete就是现在好了，如下图</p><p>后面出现类似的问题，同样的方法解决就好了</p><p><img src="/images/1577235650800.jpg" alt="1-7" title="本博客的主人最帅"></p><p>之后继续配置，输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql zabbix-server-mysql</span><br></pre></td></tr></table></figure><p><img src="/images/1577235837540.jpg" alt="1-8" title="本博客的主人最帅"></p><p>输入这行命令，看见create.sql.gz那就进入到这个文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/share/doc/zabbix-server-mysql-3.0.28</span><br></pre></td></tr></table></figure><p>之后解压create.sql.gz这个压缩文件，即可获得初始化sql脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunzip create.sql.gz</span><br></pre></td></tr></table></figure><p>之后输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll create.sql</span><br></pre></td></tr></table></figure><p><img src="/images/1577235977026.jpg" alt="1-9" title="本博客的主人最帅"></p><p>是这样的效果，就是正确的！</p><p>但是需要注意的是，此sql脚本中sql只会在对应的数据库中初始化zabbix所需要的数据库表，但是不会创建zabbix数据库，所以，创建zabbix数据库这一步骤，还是需要我们手动进行的。所以，此处我们先动手创建zabbix的数据库，过程如下：</p><p>进入数据库</p><p><img src="/images/1577236249847.jpg" alt="1-10" title="本博客的主人最帅"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create database zabbix charset 'utf8';</span><br><span class="line"></span><br><span class="line">grant all on zabbix.* to zabbix@'localhost' identified by '123456';</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>zabbix数据库初始化完成后，执行对应的sql初始化脚本，输入命令：</p><p><img src="/images/1577237348431.jpg" alt="1-11" title="本博客的主人最帅"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p -Dzabbix &lt; /usr/share/doc/zabbix-server-mysql-3.0.28/create.sql</span><br><span class="line"><span class="meta">#</span> /usr/share/doc/zabbix-server-mysql-3.0.28/create.sql 对应的是你create.sql所在的地点</span><br></pre></td></tr></table></figure><p>进入数据库，zabbix库，查看表，出现这些表，就是导入成功</p><p><img src="/images/1577237406737.jpg" alt="1-11" title="本博客的主人最帅"></p><h5 id="配置zabbix-server端并启动"><a href="#配置zabbix-server端并启动" class="headerlink" title="配置zabbix server端并启动"></a>配置zabbix server端并启动</h5><p>server端已经安装完毕，并且数据库也已经初始化，现在我们开始配置server端，编辑zabbix server端的配置文件</p><p><img src="/images/1577238444017.jpg" alt="1-11" title="本博客的主人最帅"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/zabbix/zabbix_server.conf</span><br></pre></td></tr></table></figure><p>此处列出我们可能会经常修改的参数，如下：</p><blockquote><p><code>LIstenPort=10051</code>  </p><p>服务器默认端口</p></blockquote><blockquote><p><code>SourceIP=</code></p><p>通过SourceIP参数可以指定服务器的源IP，当server端㕛多个IP地址时，我们可以指定服务器端使用固定的IP于agent端进行通讯，为了安全起见，agent端会基于IP进行一定的访问控制，也就是说agent端只允许指定IP以server端的身份菜鸡被监控主机的数据，如果IP不对应，租不允许采集被监控主机的数据，所以，当server端 有多个IP时，我们可以通过SourceIP参数，指定server端 通过哪个IP采集被监控主机的数据</p></blockquote><blockquote><p><code>LogType=file=file</code></p><p>通过LogType参数，可以指定通过哪种方式记录日志，此参数可以设置为三种值，system、file、console，system表示将日志发往syslog，file表示使用指定的文件 作为日志 文件，console表示将日志发往控制台，默认为file</p></blockquote><blockquote><p><code>LogFile=/var/log/zabbix/zabbix_server.log</code></p><p>当LogType设置为file时，通过LogFile参数设置日志文件位置</p></blockquote><blockquote><p><code>LogFileSize=0</code></p><p>指明日志文件达到 多大是自动滚动，单位为MB，如果设置LogFileSize为50时，表示日志大小达到 50MB滚动一次，设置为0表示日志文件不寄回滚动，所有入职保存在一个文件中</p></blockquote><blockquote><p><code>Debuglevel=3</code></p><p>通过DebugLevel参数可以定义日志的详细程度，即为日志级别</p></blockquote><blockquote><p><code>DBHost=localhost</code></p><p>通过DBHost参数设置zabbix数据库 所在的服务器IP，由于此处zabbix于mysql安装在同一个服务器上，所以此处设置为localhost</p></blockquote><blockquote><p><code>DBUser=zabbix</code></p><p>通过DBUser指定zabbix数据库用户名</p></blockquote><blockquote><p><code>DBPassword=</code></p><p>通过DBPassword指定zabbix数据库用户的密码</p></blockquote><blockquote><p><code>DBPort=3306</code></p><p>通过DBPort指定zabbix所在数据库服务监听的端口号</p></blockquote><blockquote><p><code>DBSocket=/var/lib/mysql/mysql.sock</code></p><p>如果数据库服务于server端在同一台服务器上，可以通过DBSocket指定数据库本地套接字文件位置，但是需要注意，即使设置了mysql套接字文件的位置，还是需要配合DBHost参数，否则在登录zabbix控制台时，可能会出现警告，在zabbix server的log中，也可能会出现无法连接数据库的提示</p></blockquote><p>根绝上述的配置参数的解释，根据具体需求进行实际配置即可。</p><p>配置完成后，启动zabbix服务端即可，输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl start zabbix-server.service</span><br><span class="line"><span class="meta">#</span> 输入</span><br><span class="line">ss -tnl</span><br><span class="line"><span class="meta">#</span> 查看10051端口是否被监听</span><br></pre></td></tr></table></figure><p>启动后,10051端口已经被监听，如下图</p><p><img src="/images/1577238791164.jpg" alt="1-11" title="本博客的主人最帅"></p><h5 id="安装zabbix-web端"><a href="#安装zabbix-web端" class="headerlink" title="安装zabbix web端"></a>安装zabbix web端</h5><p>zabbix web 可以安装在单独的主机上，只要能连接到zabbix database所在的数据库即可。但是此处为了方便，我们将zabbix web与mysql以及 zabbix server 安装在同一台服务器上。</p><p>因为 zabbix web 需要lamp环境，所以，此处我们将会依赖到的环境先安装好。</p><p>代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install httpd php php-mysql php-mbstring php-gd php-bcmath php-ldap php-xml</span><br></pre></td></tr></table></figure><p>完成上述步骤后，安装zabbix web所需要的两个包，对应版本为3.0.7.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install zabbix-web zabbix-web-mysql --skip-broken</span><br></pre></td></tr></table></figure><p>查看刚才安装完成的zabbix-web程序包，可以看到，zabbix-web的web应用存放在/usr/share/zabbix中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql zabbix-web</span><br></pre></td></tr></table></figure><p><img src="/images/1577239418954.jpg" alt="1-11" title="本博客的主人最帅"></p><p>zabbix还是比较贴心的，针对httpd，zabbix-web包中已经包含了对应zabbix文档路径的配置文件。</p><p>输入：</p><p><img src="/images/1577239584104.jpg" alt="1-11" title="本博客的主人最帅"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/httpd/conf.d/zabbix.conf</span><br></pre></td></tr></table></figure><p><img src="/images/1577239635853.jpg" alt="1-11" title="本博客的主人最帅"></p><p>以看到，针对zabbix web的文档路径，此文件中已经为我们准备了默认设置，如果不使用httpd的虚拟主机，只要把时区稍加改动即可直接使用</p><p>而此处，我们使用httpd的虚拟主机访问zabbix web ，所以，将配置文件爱你中的内容改为如下配置，同时将时区修改为<code>亚洲上海</code></p><p><img src="/images/1577240031191.jpg" alt="1-11" title="本博客的主人最帅"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost 39.106.84.122&gt;</span><br><span class="line">servername zabbix.zhanglei.net</span><br><span class="line">documentroot /usr/share/zabbix</span><br><span class="line"></span><br><span class="line">        Alias /zabbix /usr/share/zabbix</span><br><span class="line"></span><br><span class="line">        &lt;Directory "/usr/share/zabbix"&gt;</span><br><span class="line">                Options FollowSymLinks</span><br><span class="line">                AllowOverride None</span><br><span class="line">                Require all granted</span><br><span class="line"></span><br><span class="line">                &lt;IfModule mod_php5.c&gt;</span><br><span class="line">                        php_value max_execution_time 300</span><br><span class="line">                        php_value memory_limit 128M</span><br><span class="line">                        php_value post_max_size 16M</span><br><span class="line">                        php_value upload_max_filesize 2M</span><br><span class="line">                        php_value max_input_time 300</span><br><span class="line">                        php_value max_input_vars 10000</span><br><span class="line">                        php_value always_populate_raw_post_data -1</span><br><span class="line">                        php_value date.timezone Asia/Shanghai</span><br><span class="line">                &lt;/IfModule&gt;</span><br><span class="line">        &lt;/Directory&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;Directory "/usr/share/zabbix/conf"&gt;</span><br><span class="line">                Require all denied</span><br><span class="line">        &lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Directory "/usr/share/zabbix/app"&gt; </span><br><span class="line">                Require all denied</span><br><span class="line">        &lt;/Directory&gt; </span><br><span class="line"></span><br><span class="line">        &lt;Directory "/usr/share/zabbix/include"&gt; </span><br><span class="line">                Require all denied</span><br><span class="line">        &lt;/Directory&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;Directory "/usr/share/zabbix/local"&gt;</span><br><span class="line">                Require all denied</span><br><span class="line">        &lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><p>配置为完成后，启动httpd服务。</p><p><img src="/images/1577240159396.jpg" alt="1-11" title="本博客的主人最帅"></p><p>好了，zabbix web安装配置完成</p><p>访问 服务器IP/zabbix，就可以看到如下图的zabbix安装页面</p><p>配置好之后，别忘记把把<code>/usr/share/zabbix</code>复制到<code>/var/www/html</code>里面</p><p>之后，IP/zabbix/setup.php访问即可，就可出现如下图的样子。</p><p><img src="/images/1577246280547.jpg" alt="1-11" title="本博客的主人最帅"></p><h5 id="初始化zabbix-配置"><a href="#初始化zabbix-配置" class="headerlink" title="初始化zabbix 配置"></a>初始化zabbix 配置</h5><p>完成上述安装步骤后就可以看到zabbix安装页面。点击下一步</p><p>不出意外的话，你们也会这样。哈哈哈</p><p><img src="/images/1577246345326.jpg" alt="1-11" title="本博客的主人最帅"></p><p>按照错误的这四个参数。修改/etc/php.ini文件中的配置就行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/php.ini</span><br></pre></td></tr></table></figure><p><code>post_max_size=16M</code></p><p> <code>max_execution_time=300</code></p><p> <code>max_input_time=300</code></p><p> <code>date.timezone =Asia/Shanghai</code></p><p>找到这四个，直接把配置改了就好，和我的一样就行。</p><p>如果嫌找的麻烦，直接搜索，输入‘/’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/你想搜索的关键字，或者全拼</span><br></pre></td></tr></table></figure><p>改好之后重新启动下服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart httpd.service</span><br></pre></td></tr></table></figure><p>之后再重新加载下页面，就会像如下图：</p><p><img src="/images/1577253128156.jpg" alt="1-11" title="本博客的主人最帅"></p><p>可以看到，zabbix检查的环境已经全部满足，所以点击下一步！</p><p><img src="/images/1577253184977.jpg" alt="1-11" title="本博客的主人最帅"></p><p>此处zabbix需要配置数据库连接，此处配置数据库的类型，IP，端口，数据库名，用户密码等信息，端口填写0表示使用默认端口(3306端口)</p><p>请确定概要信息无误，点击下一步</p><p><img src="/images/1577255155455.jpg" alt="1-11" title="本博客的主人最帅"></p><p><img src="/images/1577255204397.jpg" alt="1-11" title="本博客的主人最帅"></p><p><img src="/images/1577255235198.jpg" alt="1-11" title="本博客的主人最帅"></p><p>之后，就会进入登录页面，默认账号admin，密码zabbix</p><p><img src="/images/1577255289782.jpg" alt="1-11" title="本博客的主人最帅"></p><p>登录完成后，可以看到zabbix的仪表盘</p><p><img src="/images/1577255350824.jpg" alt="1-11" title="本博客的主人最帅"></p><p>全是英文，作为一个爱国的知识青年，肯定看不爽，所以 ，我们可以把它调成中文版</p><p><img src="/images/1577255416702.jpg" alt="1-11" title="本博客的主人最帅"></p><p>语言选择中文，点击 更新即可，蛋黄思思你可能无法在语言中看到中文的选项，如果无法找到中文选项，则代表你的配置文件中的中文选项显示属性为false</p><p><img src="/images/1577255448186.jpg" alt="1-11" title="本博客的主人最帅"></p><p>当然了，如果你没有这项选择，那么你可以修改下如下文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/share/zabbix/include/locales.ini.php</span><br></pre></td></tr></table></figure><p><img src="/images/1577255626516.jpg" alt="1-11" title="本博客的主人最帅"></p><p>找到中文对应的值，将显示属性设置为true即可，如上图所示</p><p>但是，你可能还会遇到中文乱码情况，如果遇到中文乱码，可以从Windows中挑选一个顺眼的中文字体，将对应字体放置到inux中 zabbix web的字体目录中，因为我们使用的是rpm包安装的zabbix web，所以zabbix web默认字体目录为 /usr/share/zabbix/fonts/，Windows中的字体文件后缀名如果为TTF，当我们把对应字体文件拷贝到zabbix字体目录是，需要修改其后缀名为小写的ttf（如果本来就是小写的则不用任何修改了），字体文件上传完毕后，修改/usr/share/zabbix/include/defines.inc.php配置文件，将下图中显示字体部分修改为刚才上传的字体文件对应的名称即可。</p><p>好了，上述操作完成后，zabbix控制台即显示中文了。</p><p>但是你可能会在访问zabbix控制台时，可能会发现如下提示：</p><p><img src="/images/1577255896543.jpg" alt="1-11" title="本博客的主人最帅"></p><p>如果出现图中的提示，可能是由如下几个原因引起的：</p><p>1、zabbix-server未正常启动</p><p>2、已经开启selinux，但是没有正常设置对应权限</p><p>3、zabbix-server未能正常连接数据库</p><p>4、zabbix.conf.php文件中$ZBX_SERVER参数对应的主机名不能正常解析</p><p>5、其他原因，需要查看zabbix server 日志</p><p>如果在访问zabbix控制台时并没有出现上述提示，忽略上述描述即可。</p><p>为了更加安全，我们不应该使用管理员的默认密码，所以，我们最好先修改管理员密码</p><p><img src="/images/1577256061549.jpg" alt="1-11" title="本博客的主人最帅"></p><p><img src="/images/1577256113248.jpg" alt="1-11" title="本博客的主人最帅"></p><p>好了。基本配置已经配置完成了，我们以后的监控工作就要围绕着这个web界面展开了！</p><h5 id="Zaabix-agent-安装"><a href="#Zaabix-agent-安装" class="headerlink" title="Zaabix agent 安装"></a>Zaabix agent 安装</h5><p>现在万事具备，就差agent端了，agent端安装也非常方便，直接<strong>被监控主机</strong>上安装如下两个包即可。</p><p><code>当然了，在安装之前，指定要把上面的准备工作全都做好，否则会出错的哦！</code></p><p>此处被管理主机 centos7，已经配置好了对应的zabbix源，agent版本可以跟server端版本  不一致，没有关系，安装即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y zabbix-agent zabbix-sender</span><br></pre></td></tr></table></figure><p>我们查看一下zabbix-agent都安装了什么文件，当然，最重要的就是zabbix_agentd.conf这个配置文件了</p><p><img src="/images/1577256337395.jpg" alt="1-11" title="本博客的主人最帅"></p><p>还记得我们在刚开始介绍zabbix时说过“主动模式”与“被动模式”吗？这两种模式的相关配置，都需要在zabbix_agentd.conf中定义，打开这个文件，我们来配置一下常用的agent端配置。首先，可以看到配置文件中有很多注释，打开配置文件，首先看到的就是”通用参数配置段”，我们可以在此配置段配置zabbix_agent进程的进程编号文件路径，存储日志方式，日志文件位置，日志滚动阈值等常用设定，细心如你一定已经发现，zabbix_agent配置文件的”通用配置段”中的参数大多数与zabbix_server配置文件中的常用参数意义相同，所以，此处不再过多赘述，如果没有特殊需要，保持默认即可。 </p><p><img src="/images/1577272480659.jpg" alt="1-11" title="本博客的主人最帅"></p><p>此处先说说我们马上会用到的两个配置，如下图红框中的注释所描述的，“被动模式配置段”与“主动模式配置段”</p><p><img src="/images/1577273106840.jpg" alt="1-11" title="本博客的主人最帅"></p><p><img src="/images/1577273063509.jpg" alt="1-11" title="本博客的主人最帅"></p><p>我们已经在最开始的概念介绍中，描述过，“主动模式”和“被动模式”都是对于agent端来说的，而且它们可以同时存在，，并不冲突。</p><p>我们先来看看“被动模式”的相关配置参数。</p><p>被动模式相关参数如下：</p><p>Sserver：用于指定允许哪台服务器拉去当前服务器的数据，当agent端工作于被动模式，则代表server端会主动拉取agent端数据，那么server端的IP必须与此参数的IP对应，此参数用于实现基于IP的访问控制，如果有多个IP，可以使用逗号隔开。</p><p>ListenPort：用于指定当agent端工作于被动模式所监听的端口号，默认端口号10050，也就是说，server端默认访问10050端口，从而拉取数据。</p><p>ListenIP：用于指定agent端工作于被动模式时所监听的IP地址，默认值为0.0.0.0，表示监听本机的所有IP地址。</p><p>StartAgents：用于指定预生成的agent进程数量。</p><p>主动模式</p><p>主动模式的常用参数如下：</p><p>ServerActive：此参数用于指定当agent端工作于主动模式时，将信息主动推送到哪台server上，当时有多个IP时，可以用逗号隔开。</p><p>Hostname：此参数用于指定当前主机的主机名，server端通过此参数对应的主机名识别当前主机。</p><p>RefreshActiveChescks：此参数用于指明agent端没多少秒主动将采集到的数据发往server端。</p><p>此处，我们同时设置“被动模式”与“主动模式”的如下参数，其他保持默认即可，修改完成后保存退出。</p><p>Server=47.96.230.50</p><p>ServerActive=47.96.230.50</p><p>Hostname=testzbx1.zsythink.net</p><p>配置文件修改完成后，启动agent端进程</p><p><img src="/images/1577273181431.jpg" alt="1-11" title="本博客的主人最帅"></p><p>好了，agent端也已经安装好了！</p><h4 id="在-Zabbix-中添加主机"><a href="#在-Zabbix-中添加主机" class="headerlink" title="在 Zabbix 中添加主机"></a>在 Zabbix 中添加主机</h4><p>在添加主机之前，我们先把工作场景描述清楚。然后再根据描述的工作场景进行演示</p><p>假设，我们想要使用zabbix监控一台linux服务器，那么，我们肯定要将这个服务器纳入zabbix的管理范围，而“添加主机”这个操作，就是将被监控的主机纳入zabbix管理范围的一个必须操作，如果我们有10台主机都需要呗zabbix监控呢？没错，这10台主机必须被添加到zabbix的监控列表中，在zabbix中，我们将被监控的对象称为“主机”，“主机”不一定是服务器，也可以是<code>路由器</code>，<code>交换机</code>等网络设备，而且，根据主机的属性、角色、特征的不同，我们还能够将主机分组。</p><p>比如，我们有10台服务器，10台服务器中，有3台window服务器，有7台linux服务器，那么，我们还可以按照操作系统的不同，将他们分成两组，Windows服务器组于linux服务器组，或者我们不按照操作系统对主机进行分组，而是根据服务器的角色对主机分组。</p><p>比如，一共10台服务器，3台是是提供ldap服务的，2台是提供web服务的，5台是提供数据库服务的，我们也可以把他们按照角色分成3组，ladp主机组、web主机组、db主机组，当然，我们也只是举个例子。</p><p>实际应用中，具体怎样分组，是根据实际需求视情况而定的，那么，为什么要将主机分组呢？这是为了方便管理，因为同一类主机需要被监控的指标很有可能 都是相同的，所以将他们分为一组方便管理，当然了，这就是后话，我们后面再聊！</p><p>上面一段话中，我们提到了两个zabbix的常用术语，“主机”与“主机组”，我们再来总结一遍：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、host（主机）：需要zabbix监控的对象，被称为主机，主机必须属于某个主机组。</span><br><span class="line"></span><br><span class="line">2、hostgroup（主机组）：“主机组”也被称为“主机群组”，是由具有相同属性、特征、角色的多个主机组成的逻辑单元。</span><br></pre></td></tr></table></figure><p>理解 上述两个术语，并且能够在zabbix中使用他们，就是我们所要达到的目的。</p><p>那么我们来看看怎样在zabbix添加一台主机，在动手添加主机之前。先说明下我们的环境。</p><p>我们已经将zabbix-server、zabbix-database、zabbix-web安装在了39.106.84.122上。</p><p>同时，我们将zabbix-agent安装在了47.97.172.176上。</p><p>所以此处，47.97.172.176就是被监控的对象 ，我们需要将176添加为zabbix主机。</p><p>首先呢，打开我们的zabbix web 控制台，看看都有那些“主机组”。</p><p>点击“配置“—-”主机群组“，可以看到，系统默认已经为我们准备了一些主机组，如果这些主机组不满足我们的需要，我们也可以创建新的主机组</p><p>点击下图中的“创建主机群组”按钮，即可创建主机组，但是，我们还不用深入研究主机组，此处只是让大家了解一下，对主机有一个初步的认识。</p><p><img src="/images/1577320713453.jpg" alt="1-11" title="本博客的主人最帅"></p><p>同样，点击<code>配置</code>—–<code>主机</code>，即可查看已经被加入zabbix主机列表的主机，可以看到，zabbix默认将zabbix server添加为了一台主机，以便 可以自己监控自己，但是此处，我们需要添加一台我们自己的主机，就是47.97.172.176，</p><p>点击<code>创建主机</code>，点击创建主机之前，可以选择左侧的<code>群组</code>下来菜单，以确定将要创建的主机所在的主机组，当然，我们也可以先不选主机组，直接点击<code>创建主机</code>按钮。</p><p><img src="/images/1577322582225.jpg" alt="1-11" title="本博客的主人最帅"></p><p>点击<code>创建主机</code>按钮之后，即可看见类似如下界面，为了更好的描述每个步骤，具体解释参靠下图后面的注释列表。</p><p><img src="/images/1577322873679.jpg" alt="1-11" title="本博客的主人最帅"></p><p><code>1</code>、我们可以在主机名的文本框中填写被监控主机的主机名称。</p><p><code>2</code>、<strong>可见名称</strong>一般使用剪短的、易读的、见名知义的名称表示主机即可。</p><p><code>3</code>、我们可以选择将要创建的主机属于哪个主机组，当然，如果没有合适的主机组，我们也可以直接在创建主机时，直接创建新的主机组，我上面说过，每个主机必须存在于某个主机组中，所以，主机组是必须的</p><p><code>4</code>、如果在三的<code>3</code>的位置上没有对应的、可用的、合适的主机组，我们可以直接在<strong>新的群组</strong>中创建当前主机需要的主机组。</p><p><code>5</code>、选择通过哪种接口监控当前主机，可选的方式有IPMI接口、JMX接口、SNMP接口、agent接口，我们说过，”主机”在zabbix中，可以是服务器，路由器，交换机等等硬件设备，有的硬件设备只支持某种接口，所以，当我们添加主机时，会让我们选择通过哪种合适的接口监控它，具体各接口的适用场景我们已经在第一篇介绍zabbix概念的文章中描述过，此处不再赘述，当然，如果一台主机能被多种接口所监控，也可以同时配置多个接口监控这台主机，但是当前，我们需要监控的主机是一台Linux服务器，而且已经安装了对应的agent端，所以，此处，我们只使用agent接口对当前主机进行监控，而使用agent接口时，可以通过IP连接到对应agent，也可以使用主机名连接到对应agent，而此处，我们选择使用IP地址连接到对应的agent，IP地址就是我们将要添加的主机的IP，47.97.172.176  ，对应端口为默认的10050，如果你想要使用主机名连接到对应的agent，那么需要保证主机名能够被正常解析到47.97.172.176上，此处不再赘述，如果有多个IP可以连接到对应agent，可以点击”添加”，添加一条新的IP。 </p><p><code>6</code>、对将要添加的主机进行描述，添加响应的描述信息即可。</p><p><code>7</code>、表示是否使用zabbix proxy监控当前主机，虽然上图中。此处翻译为“由agent代理程序检测”，但是实际是用于指定zabbix proxy的，与zabbix agent并没有关系，但是因为我们没有配置zabbix_proxy，所以此处保持默认即可</p><p>好了，按照上述界面中的配置进行设置以后，点击”添加”按钮，即可简单的添加一台主机，可以看到，47.97.172.176已经被添加到了主机列表中。 </p><p><img src="/images/1577323895393.jpg" alt="1-11" title="本博客的主人最帅"></p><p>而且，如果此时我们再次查看主机组，已经发现，TestHosts主机组已经被添加了，而且其中的成员已经包含了testzbx1主机。 </p><p><img src="/images/1577324037183.jpg" alt="1-11" title="本博客的主人最帅"></p><p>回到主机列表，可以看到我们刚才添加的testzbx1主机，但是testzbx1主机的”可用性”对应的4中接口都是灰色的。 </p><p><img src="/images/1577324150680.jpg" alt="1-11" title="本博客的主人最帅"></p><p><img src="/images/1577324218152.jpg" alt="1-11" title="本博客的主人最帅"></p><p>第二个图我们可以看见，何金存的主机已经成功的卑微监控了，</p><p>上图中，而ZBX就代表agent接口，虽然我们在添加主机时，配置了通过agent监控对应主机，但是，由于我们并没有配置监控主机的任何指标，所以，ZBX仍然是灰色的，也就是说，我们现在只是将192.168.1.107加入了zabbix的监控范围，但是并没有对它进行任何实际的监控，因为我们还没有配置任何”监控项”，至于怎样配置监控项，且听下回分解。 </p><h4 id="在Zabbix中添加监控项"><a href="#在Zabbix中添加监控项" class="headerlink" title="在Zabbix中添加监控项"></a>在Zabbix中添加监控项</h4><p>上面呢已经描述了zabbix添加主机，但是，我们还并没有对主机进行任何指标的实际监控那么现在，我们就来说说，具体怎样监控我们想要监控的指标。</p><p>首先，打开我们zabbix控制台，点击<code>配置</code>—<code>主机</code>，可以看到我们上次创建的主机，虽然我们为对应的被监控主机安装了agent，但是主机对应的ZBX仍然显示灰色，代表我们还没有任何监控项被检测到，那么现在，我们来为“何金存”主机添加一个监控项。</p><p><img src="/images/1577330551358.jpg" alt="1-11" title="本博客的主人最帅"></p><p>点击“何金存”主机上的<code>监控项</code>，如下图所示位置。</p><p><img src="/images/1577330697290.jpg" alt="1-11" title="本博客的主人最帅"></p><p>进入监控项配置界面后，可以根据一些条件，筛选出已经存在的一些控制项，但是我们并没有任何监控项，所以此处 ，我们直接点击<code>创建监控项</code>按钮。以便新建监控项。</p><p><img src="/images/1577330817857.jpg" alt="1-11" title="本博客的主人最帅"></p><p>假如，现在我们想要监控“何金存”这台主机的CPU的上下文切换此处，那么我们可以在此界面进行如下配置</p><p><img src="/images/1577330929623.jpg" alt="1-11" title="本博客的主人最帅"></p><p>首先，在名称文本框中设置监控项的名称，我们此处监控的指标cpu上下文切换次数，所以，命名次监控项为“cpu context swiyches”</p><p>因为我们在“何金存”这台主机上安装了zabbix agent，所以，此处类型保持默认，选择zabbix客户端。</p><p>在键值一栏中，我们可以选择对应的key，也就是说，我们通过哪个key，这些key都是zabbix自带的key，这些key一般都是系统级别的通用的监控项所能够用到的key，如果这些“键”不能满足我们的需求，我们则需要自定义key，这是后话，后面再聊，此处，我们选择system/cpu.switches</p><p><img src="/images/1577331010819.jpg" alt="1-11" title="本博客的主人最帅"></p><p><img src="/images/1577331030747.jpg" alt="1-11" title="本博客的主人最帅"></p><p><img src="/images/1577331048400.jpg" alt="1-11" title="本博客的主人最帅"></p><p><img src="/images/1577331062325.jpg" alt="1-11" title="本博客的主人最帅"></p><p><img src="/images/1577331117868.jpg" alt="1-11" title="本博客的主人最帅"></p><p>选择完可以看见，key的值已经自动填充到了“键值”的文本框中</p><p><img src="/images/1577331507814.jpg" alt="1-11" title="本博客的主人最帅"></p><p>说到这，我们可以通过命令行，来看下对应的“键”返回信息到底是什么样子的？</p><p>之前的我介绍过zabbix概念是已经说过：管理员可以在server端使用另一个名为zabbix_get的工具，测试是否能够从agent端拉取数据。</p><p><img src="/images/1577340453222.jpg" alt="1-11" title="本博客的主人最帅"></p><p>我们就是通过agent接口监控数据的，agent监听在10050端口上，此处保持默认即可。</p><p>而我们刚才也看到了，通过zabbix_get获取到的system.cpu.switches的数据，都是一些十进制的整数，所以，信息类型选择数字，数据类型选择十进制。</p><p>数据更新间隔表示每个多长时间获取一次监控项对应的数据，为了演示方便，能尽快获取到数据，我们设定位每隔30秒获取一次监控信息，此处表示每隔30秒获取一次47.97.172.176主机的cpu上下文切换次数 ，但是需要注意，在生产环境中，如果不是特别重要的、敏感的、迅速变化的数据，不要获取的这么频繁，因为如果我们的监控项变得特别多时，获取信息的时间间隔过于频繁会带来巨大的监控压力，同时对数据库的写入也是一种考验。</p><p>当然，我们也可以灵活的定义时间间隔，比如，周一到周五我们的业务量比较少，可以10分钟获取一次数据，而周六周日的业务量会剧增，为了实时监控，可以设置5分钟获取一次数据，这里只是举个例子，如果有类似的需求，可以通过“自定义事件间隔”配置段，添加不同时间段的不同检测频率。</p><p><img src="/images/1577341079573.jpg" alt="1-11" title="本博客的主人最帅"></p><p>因为我们每隔30秒就获取一次数据，那么这些数据都会变成历史，存入数据库中，通过上图中的开始数据文本框，可以设置历史数据的保存时长。</p><p>上图中，我们设置历史数据保存8天，趋势数据是什么意思呢？趋势数据就是每个小时收集到历史数。</p><p>从上图中，还可以看到有一个趋势数据保存天数，趋势数据是什么意思呢？趋势数据就是每个小时收集到的历史数据中的最大值、最小值，平均值以及每个小时收集的到的历史数据的数据量，所以，趋势数据每小时收集一次，数据量不会特别大，一般情况下，历史数据的保留时间都比趋势数据保留时间短很多，因为历史数据比较多，如果我们监控的主机非常多，而且监控的频率 特别频繁，那么数据库的压力则会变得非常大。</p><p>继续往下看，可以看到储存值于查看两个下拉框。</p><p><img src="/images/1577341472464.jpg" alt="1-11" title="本博客的主人最帅"></p><p>我们点开储存值下拉框，可以看到三个选项，不变、差量（每秒频率）、差量（简单变化）</p><p><img src="/images/1577341562547.jpg" alt="1-11" title="本博客的主人最帅"></p><p>那么这些值都是什么意思呢？</p><p><code>不变</code>：表示获取到的值是什么样子的，就在数据库中存储为什么样子。</p><p><code>差量（简单变化）</code>：表示本次收集的信息值 减去 上一次收集到的信息值 得出的差值</p><p><code>差量（每秒速率）</code>：表示本次收集到的值 减去 上次收集到的值以后，再除于两次收集信息的间隔时间。</p><p>而此处，我们监控的指标为cpu上下文切换次数，这是一个不断增长的整数值，所以，我们选择<strong>差量（每秒速率）</strong>最合适</p><p>这样发=我们就能 够监控到不同时间段内cpu上下文切换的频率了。</p><p>那么查看值 是什么意思呢？查看值可以改变监控数据的展示方式，以便监控人员更容易理解，此处我们保持默认即可，在实际用到是我们在做解释。</p><p><img src="/images/1577341940128.jpg" alt="1-11" title="本博客的主人最帅"></p><p>新的应用集  与  应用集  是什么意思呢？</p><p><img src="/images/1577341996936.jpg" alt="1-11" title="本博客的主人最帅"></p><p>我们可以把“应用集”理解为同一类型的监控项的集合，“应用集”英文原词为application，application为一组item（监控项）的集合，比如，我们有3个监控项，他们分别监控“磁盘使用率”，“磁盘写入速率”，“磁盘读取速率”，虽然他们监控指标不同，但是他们都是监控“磁盘”的监控项 ，所以，我们可以把他们归类为“磁盘”应用集，同理，如果有2个监控项，一个是监控nginx连接数量的，一个是监控nginx请求数量的，虽然他们监控的指标不同，但是他们都是监控nginx相关指标的，所以，我们可以把他们归为nginx应用集。</p><p>但是，由于我们没有创建过任何应用集，所以上图中，应用集选择框中没有任何可选择应用集，如果没有可选的合适的应用集，我们可以直接在“新的应用”文本框中填入要创建的应用集名称，那么对应应用集会自动被创建当前监控项 也会自动归类为这个应用集。</p><p><img src="/images/1577342433074.jpg" alt="1-11" title="本博客的主人最帅"></p><p>继续聊，”填入主机资产纪录栏位”我们后面再聊。 </p><p>描述信息栏填写关于这个监控项的相关描述。 </p><p>“已启用”默认被勾选，表示此监控项被创建后，立即生效，即创建此监控项后立即开始监控。 </p><p>好了，监控项的配置我们已经解释的七七八八了，示例配置如下，点击添加按钮, 注：为了更快的获取演示效果，此处将数据更新间隔设置为5秒，但是生产环境中请仔细考虑具体设置为多少秒比较适合生产环境的需求。 </p><p><img src="/images/1577349633413.jpg" alt="1-11" title="本博客的主人最帅"></p><p><img src="/images/1577342566211.jpg" alt="1-11" title="本博客的主人最帅"></p><p>点击添加按钮以后，可以看到，何金存主机的第一个监控项已经被添加，而且处于已用状态。</p><p><img src="/images/1577342709516.jpg" alt="1-11" title="本博客的主人最帅"></p><p>点击监控项旁边的“应用集”</p><p><img src="/images/1577342794093.jpg" alt="1-11" title="本博客的主人最帅"></p><p>可以看到，应用集中已经存在了cpu应用集，而且这个应用集中已经存在一个监控项，就是我们刚才创建的”cpu context switches”监控项。 </p><p><img src="/images/1577343339745.jpg" alt="1-11" title="本博客的主人最帅"></p><p>从对应的主机组中找到对应的主机，</p><p><img src="/images/1577344402324.jpg" alt="1-11" title="本博客的主人最帅"></p><p>点击过滤按钮之后，应该可以看到我们刚才创建的监控项，已经存在了部分数据，如果你刚刚创建完监控项，不要着急立马查看“监控项”数据，因为他可能需要一段时间收集数据。</p><p>但是，如果超出正常收集数据的时间后，很长时间以内仍然无法收集到数据，那么有可能 是因为agent端与server端时间不同步引起的，请确定你的agent端与server端的时间是同步的。</p><p>过程中出现了一个问题</p><p><img src="/images/1577348901660.jpg" alt="1-11" title="本博客的主人最帅"></p><p><img src="/images/1577348933997.jpg" alt="1-11" title="本博客的主人最帅"></p><p>这个问题，检查两处，如果其他问题也是首先想这两处。</p><p>1、防火墙是否关闭</p><p>2、进入/etc/zabbix/zabbix_agentd.conf配置文件，找到<code>Server</code>，把“127.0.0.1”改成监控服务器IP</p><p><img src="/images/1577349156980.jpg" alt="1-11" title="本博客的主人最帅"></p><p>好，接着往下看啊</p><p>可以看到，“cpu context switches”这个监控项已经存在数据，我们点击对应的“图形”连接</p><p><img src="/images/1577349426989.jpg" alt="1-11" title="本博客的主人最帅"></p><p>点击上图中的<code>图形</code>连接，可以看到如下界面，zabbix已经监控到了对应的cpu上下文切换频率，并且绘制出了对应的“图形”</p><p><img src="/images/1577351286152.jpg" alt="1-11" title="本博客的主人最帅"></p><p>如果没有图形就按照下图来操作即可。操作完之后还是没有图形，那就是没数据。</p><p><img src="/images/1577349916527.jpg" alt="1-11" title="本博客的主人最帅"></p><p><img src="/images/1577349869444.jpg" alt="1-11" title="本博客的主人最帅"></p><p><img src="/images/1577349793762.jpg" alt="1-11" title="本博客的主人最帅"></p><p>我们已经为主机添加了第一个监控项，并且已经成功监控到了对应的数据，好了，我们已经入门了。 </p><p>本文参考网站  –  <a href="http://www.zsythink.net/archives/447" target="_blank" rel="noopener">http://www.zsythink.net/archives/447</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Zabbix-监控系统&quot;&gt;&lt;a href=&quot;#Zabbix-监控系统&quot; class=&quot;headerlink&quot; title=&quot;Zabbix 监控系统&quot;&gt;&lt;/a&gt;Zabbix 监控系统&lt;/h2&gt;&lt;h4 id=&quot;什么是监控系统？&quot;&gt;&lt;a href=&quot;#什么是监控系统？&quot; class=&quot;headerlink&quot; title=&quot;什么是监控系统？&quot;&gt;&lt;/a&gt;什么是监控系统？&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="Zabbix" scheme="http://yoursite.com/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>上传码云</title>
    <link href="http://yoursite.com/2030/10/26/%E4%B8%8A%E4%BC%A0%E7%A0%81%E4%BA%91/"/>
    <id>http://yoursite.com/2030/10/26/上传码云/</id>
    <published>2030-10-25T16:00:00.000Z</published>
    <updated>2019-12-26T01:59:37.106Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【上传码云】命令"><a href="#【上传码云】命令" class="headerlink" title="【上传码云】命令"></a>【上传码云】命令</h3><blockquote><p>第一步，从自己的码云分支上拉下分支</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://git.oschina.net/shixunone-project/shixunone-nextcloud.git</span><br><span class="line"># https://git.oschina.net/shixunone-project/shixunone-nextcloud.git -&gt; 是你从码云项目上复制下来的</span><br></pre></td></tr></table></figure><blockquote><p>第二步，进入到下载下来的分支项目上</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd shixunone-nextcloud</span><br></pre></td></tr></table></figure><blockquote><p>第三步，没有想上传的 django 项目的，就创建一个。有 你想传的 django 项目的话，就直接拉到这个文件夹即可</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">django-admin startproject textpro1 （自己定义一个django项目名）</span><br></pre></td></tr></table></figure><blockquote><p>第四步，将 django 项目添加到码云</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add 自己定义的django项目名</span><br></pre></td></tr></table></figure><blockquote><p>第五步，将项目提交到码云</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;这里的文字随便编写&quot;</span><br></pre></td></tr></table></figure><blockquote><p>第六步，直接将项目推送到码云</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【上传码云】命令&quot;&gt;&lt;a href=&quot;#【上传码云】命令&quot; class=&quot;headerlink&quot; title=&quot;【上传码云】命令&quot;&gt;&lt;/a&gt;【上传码云】命令&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;第一步，从自己的码云分支上拉下分支&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Linux下如何关闭某个被占用的端口</title>
    <link href="http://yoursite.com/2030/10/25/Linux%E4%B8%8B%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%AD%E6%9F%90%E4%B8%AA%E8%A2%AB%E5%8D%A0%E7%94%A8%E7%9A%84%E7%AB%AF%E5%8F%A3/"/>
    <id>http://yoursite.com/2030/10/25/Linux下如何关闭某个被占用的端口/</id>
    <published>2030-10-24T16:00:00.000Z</published>
    <updated>2019-12-26T01:58:45.614Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【-Linux-】如何关闭某个被占用的端口"><a href="#【-Linux-】如何关闭某个被占用的端口" class="headerlink" title="【 Linux 】如何关闭某个被占用的端口"></a>【 Linux 】如何关闭某个被占用的端口</h3><a id="more"></a><blockquote><p>1）查找被占用的端口</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abloume@ubuntu:~$ netstat -tln | grep 8000</span><br><span class="line">tcp        0      0 192.168.2.106:8000      0.0.0.0:*               LISTEN</span><br></pre></td></tr></table></figure><blockquote><p>2）查看被占用端口的PID</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abloume@ubuntu:~$ lsof -i :8000</span><br><span class="line">COMMAND  PID  USER   FD   TYPE  DEVICE  SIZE/OFF NODE NAME</span><br><span class="line">python3  6072 root   4u   IPv4  612939  0t0  TCP *:irdmi (LISTEN)</span><br></pre></td></tr></table></figure><blockquote><p>3）kill 掉该进程</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abloume@ubuntu:~$ kill 6072 # 6027 -&gt; 进程号PID</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【-Linux-】如何关闭某个被占用的端口&quot;&gt;&lt;a href=&quot;#【-Linux-】如何关闭某个被占用的端口&quot; class=&quot;headerlink&quot; title=&quot;【 Linux 】如何关闭某个被占用的端口&quot;&gt;&lt;/a&gt;【 Linux 】如何关闭某个被占用的端口&lt;/h3&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>VUE中父子组件传参</title>
    <link href="http://yoursite.com/2030/10/15/VUE%E4%B8%AD%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    <id>http://yoursite.com/2030/10/15/VUE中父子组件传值/</id>
    <published>2030-10-14T16:00:00.000Z</published>
    <updated>2019-12-26T01:59:30.796Z</updated>
    
    <content type="html"><![CDATA[<h3 id="父子组件传值通过-props-实现，这种方式只能由父向子传递，子组件不能更新父组件内的datapro"><a href="#父子组件传值通过-props-实现，这种方式只能由父向子传递，子组件不能更新父组件内的datapro" class="headerlink" title="父子组件传值通过 props 实现，这种方式只能由父向子传递，子组件不能更新父组件内的datapro"></a>父子组件传值通过 props 实现，这种方式只能由父向子传递，子组件不能更新父组件内的datapro</h3><a id="more"></a><h4 id="子组件传值通过-emit-实现"><a href="#子组件传值通过-emit-实现" class="headerlink" title="子组件传值通过 emit 实现"></a>子组件传值通过 emit 实现</h4><blockquote><p>父组件给子组件传参：通过 props 方法传值,先定义一个子组件，在父组件中，引入子组件。这一步很简单，想必大家都会吧，这一步就不说了，直接上代码<br>父组件写法：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">      &lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div&gt;父组件&lt;/div&gt;</span><br><span class="line">        &lt;child :message=&quot;parentMsg&quot;&gt;&lt;/child&gt;  </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import child from &apos;./child&apos; //引入child组件</span><br><span class="line">export default &#123;</span><br><span class="line">components: &#123;</span><br><span class="line">            child</span><br><span class="line">        &#125;，</span><br><span class="line">    data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                parentMsg: &apos;father&apos; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><blockquote><p>子组件写法：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    props: [&quot;message&quot;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="子组件给父组件传参：通过-emit-方法传值"><a href="#子组件给父组件传参：通过-emit-方法传值" class="headerlink" title="子组件给父组件传参：通过 emit 方法传值"></a>子组件给父组件传参：通过 emit 方法传值</h4><blockquote><p>vue文档中是这么解释的：如果子组件想要改变数据呢？这在vue中是不允许的，因为vue只允许单向数据传递，这时候我们可以通过触发事件来通知父组件改变数据，从而达到改变子组件数据的目的.<br>子组件写法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  &lt;template&gt;</span><br><span class="line">    &lt;div @click=&quot;up&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">          up() &#123;</span><br><span class="line">          this.$emit(&apos;upup&apos;,&apos;hehe&apos;); //主动(dispatch)触发upup方法，&apos;hehe&apos;为向父组件传递的数据</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>父组件写法：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;child @upup=&quot;change&quot; :msg=&quot;msg&quot;&gt;&lt;/child&gt; //监听子组件触发的upup事件,然后调用change方法</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">          change(msg) &#123;</span><br><span class="line">          this.msg = msg;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;父子组件传值通过-props-实现，这种方式只能由父向子传递，子组件不能更新父组件内的datapro&quot;&gt;&lt;a href=&quot;#父子组件传值通过-props-实现，这种方式只能由父向子传递，子组件不能更新父组件内的datapro&quot; class=&quot;headerlink&quot; title=&quot;父子组件传值通过 props 实现，这种方式只能由父向子传递，子组件不能更新父组件内的datapro&quot;&gt;&lt;/a&gt;父子组件传值通过 props 实现，这种方式只能由父向子传递，子组件不能更新父组件内的datapro&lt;/h3&gt;
    
    </summary>
    
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue中Axios配置</title>
    <link href="http://yoursite.com/2030/10/11/Vue%E4%B8%ADAxios%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2030/10/11/Vue中Axios配置/</id>
    <published>2030-10-10T16:00:00.000Z</published>
    <updated>2019-12-26T01:59:25.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue中Axios配置"><a href="#Vue中Axios配置" class="headerlink" title="Vue中Axios配置"></a>Vue中Axios配置</h2><a id="more"></a><pre><code>导入：在vue文件main.js中写入（需要安装cnpm install --save axios）import axios from &apos;axios&apos;Vue.prototype.axios = axios  在 build 文件夹中的 webpack.base.conf用const createLintingRule = () =&gt; ({// test: /\.(js|vue)$/,// loader: &apos;eslint-loader&apos;,// enforce: &apos;pre&apos;,// include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)],// options: {// formatter: require(&apos;eslint-friendly-formatter&apos;),// emitWarning: !config.dev.showEslintErrorsInOverlay// }})替换第一种方法:proxyTable: {    &apos;/api&apos;: {  //使用&quot;/api&quot;来代替&quot;http://f.apiplus.c&quot;     target: &apos;http://127.0.0.1:8000/&apos;, //源地址     changeOrigin: true, //改变源     pathRewrite: {       &apos;^/api&apos;: &apos;&apos; //路径重写       }   } }第二种方法：用Django的第三方包 django-cors-headers 来解决跨域问题操作步骤：1.pip install django-cors-headers2.在settings.py中添加&apos;corsheaders.middleware.CorsMiddleware&apos;,在SessionMiddleware和CommonMiddleware的中间#允许谁请求3.在settings.py中添加CORS_ORIGIN_ALLOW_ALL = True</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Vue中Axios配置&quot;&gt;&lt;a href=&quot;#Vue中Axios配置&quot; class=&quot;headerlink&quot; title=&quot;Vue中Axios配置&quot;&gt;&lt;/a&gt;Vue中Axios配置&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Md语法入门1</title>
    <link href="http://yoursite.com/2030/10/10/MD%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2030/10/10/MD语法/</id>
    <published>2030-10-09T16:00:00.000Z</published>
    <updated>2019-12-26T01:58:48.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MD语法入门"><a href="#MD语法入门" class="headerlink" title="MD语法入门"></a>MD语法入门</h1><p>md即markdown文件的基本常用编写语法,是一种快速标记、快速排版语言，现在很多前段项目中的说明文件readme等都是用.md文件编写的，而且很多企业也在在鼓励使用这种编辑方式，特别作为一个前端从业者更要学会使用这种语言。下面就简单和大家分享一些.md基本语法</p><a id="more"></a><h3 id="一、基本符号：-gt"><a href="#一、基本符号：-gt" class="headerlink" title="一、基本符号：* - + . &gt;"></a>一、基本符号：* - + . &gt;</h3><p>基本上所有的markdown标记都是基于这四个符号或组合，需要注意的是，如果以基本符号开头的标记，注意基本符号后有一个用于分割标记符和内容的空格。</p><h3 id="二、标题"><a href="#二、标题" class="headerlink" title="二、标题"></a>二、标题</h3><ol><li><p>前面带#号，后面带文字，分别表示h1-h6,只到h6，而且h1下面会有一条横线</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure></li><li><p>相当于标签闭合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题 #</span><br><span class="line">## 二级标题 ##</span><br><span class="line">### 三级标题 ###</span><br><span class="line">#### 四级标题 ####</span><br><span class="line">##### 五级标题 #####</span><br><span class="line">###### 六级标题 #####</span><br></pre></td></tr></table></figure></li></ol><p>效果如下：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h3 id="三、列表"><a href="#三、列表" class="headerlink" title="三、列表"></a>三、列表</h3><ol><li>无序列表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//形式一</span><br><span class="line">+ a</span><br><span class="line">+ b</span><br><span class="line">+ c</span><br><span class="line">//形式二</span><br><span class="line">- d</span><br><span class="line">- e</span><br><span class="line">- f</span><br><span class="line">//形式三</span><br><span class="line">* g</span><br><span class="line">* h</span><br><span class="line">* i</span><br></pre></td></tr></table></figure></li></ol><p>以上三种形式，效果是这样的：</p><ul><li>a</li><li>b</li><li>c</li></ul><ul><li>d</li><li>e</li><li>f</li></ul><ul><li><p>g</p></li><li><p>h</p></li><li><p>i</p><blockquote><p>注意，数字后面的点只能是英文的点</p></blockquote></li></ul><blockquote><p>今天有点累，接下来的语法在我的个人博客里面，喜欢可以收藏一下。方便随时观看 <a href="https://wangxiaopeng.top" title="创作你的创作" target="_blank" rel="noopener">老渔夫爱吃锅包肉</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MD语法入门&quot;&gt;&lt;a href=&quot;#MD语法入门&quot; class=&quot;headerlink&quot; title=&quot;MD语法入门&quot;&gt;&lt;/a&gt;MD语法入门&lt;/h1&gt;&lt;p&gt;md即markdown文件的基本常用编写语法,是一种快速标记、快速排版语言，现在很多前段项目中的说明文件readme等都是用.md文件编写的，而且很多企业也在在鼓励使用这种编辑方式，特别作为一个前端从业者更要学会使用这种语言。下面就简单和大家分享一些.md基本语法&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="MD" scheme="http://yoursite.com/tags/MD/"/>
    
  </entry>
  
  <entry>
    <title>创建一个新的 Vue 项目</title>
    <link href="http://yoursite.com/2030/10/09/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84vue%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2030/10/09/创建一个新的vue项目/</id>
    <published>2030-10-08T16:00:00.000Z</published>
    <updated>2019-12-26T01:59:52.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建一个新的-Vue-项目"><a href="#创建一个新的-Vue-项目" class="headerlink" title="创建一个新的 Vue 项目"></a>创建一个新的 Vue 项目</h2><a id="more"></a><pre><code>- Vue init webpack 项目名- 一路 yes 加 空格- Npm run dev 启动项目- vue中路由去“#”：mode: &apos;history&apos;,</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创建一个新的-Vue-项目&quot;&gt;&lt;a href=&quot;#创建一个新的-Vue-项目&quot; class=&quot;headerlink&quot; title=&quot;创建一个新的 Vue 项目&quot;&gt;&lt;/a&gt;创建一个新的 Vue 项目&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>django与vue上传照片，通过 sqllite3 手动上传照片配置：</title>
    <link href="http://yoursite.com/2030/10/08/My-New-Post/"/>
    <id>http://yoursite.com/2030/10/08/My-New-Post/</id>
    <published>2030-10-07T16:00:00.000Z</published>
    <updated>2019-12-26T01:58:53.122Z</updated>
    
    <content type="html"><![CDATA[<h3 id="django与vue上传照片，通过-sqllite3-手动上传照片配置："><a href="#django与vue上传照片，通过-sqllite3-手动上传照片配置：" class="headerlink" title="django与vue上传照片，通过 sqllite3 手动上传照片配置："></a>django与vue上传照片，通过 sqllite3 手动上传照片配置：</h3><a id="more"></a><blockquote><p>第一步：</p></blockquote><ul><li>在项目文件夹中创建一个保存照片的文件夹，推荐用 ‘media’，因为后面会用到，现在记住了，后面也方便写。之后在 media 文件夹中再创建一个 ‘img’ 文件夹，负责保存照片</li></ul><blockquote><p>第二步：</p></blockquote><ul><li>在 settings 中配置：代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">MEDIA_ROOT = os.path.join(BASE_DIR,&apos;media&apos;)</span><br><span class="line"># 通过 ImageField 上传文件，会自动到‘medtia’文件夹中</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>第三步：</p></blockquote><ul><li>创建表时，创建问价字段选择 ImageField 。</li><li>ImageField 其中有个必写的字段，那就是 ‘upload_to’，这个字段后面填的是数据库存储照片时的地址。代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = models.ImageField(upload_to=&apos;img&apos;) </span><br><span class="line"># 这就是上面我们在 media 文件夹中创建 img 文件夹的原因</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>第四步：</p></blockquote><ul><li>配置路由，方便我们在vue中渲染数据</li><li>代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from django.urls import path,re_path # 这个是我们创建django项目时自带的，只有后面的re_path是我们后加的</span><br><span class="line">from . import settings</span><br><span class="line">from django.views.static import serve</span><br><span class="line">re_path(&apos;^medtia/(?P&lt;path&gt;.*)/$&apos;,serve,&#123;&apos;document_root&apos;:settings.MEDTIA_ROOT&#125;)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>在 vue 中我们该如何操作呢？</p></blockquote><ul><li><p>看下面的代码吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&apos;file&apos; id=&apos;img&apos;&gt;</span><br><span class="line">&apos;&apos;&apos;在文件框中，用 id 属性绑定&apos;&apos;&apos;</span><br></pre></td></tr></table></figure></li><li><p>下面的方法中，提取获取到的文件地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let img = document.getElementById(&apos;img&apos;).files[0]</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>OK！完成，收工</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;django与vue上传照片，通过-sqllite3-手动上传照片配置：&quot;&gt;&lt;a href=&quot;#django与vue上传照片，通过-sqllite3-手动上传照片配置：&quot; class=&quot;headerlink&quot; title=&quot;django与vue上传照片，通过 sqllite3 手动上传照片配置：&quot;&gt;&lt;/a&gt;django与vue上传照片，通过 sqllite3 手动上传照片配置：&lt;/h3&gt;
    
    </summary>
    
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>uwsgi + nginx + django部署</title>
    <link href="http://yoursite.com/2030/08/20/uwsgi%20+%20nginx%20+%20django%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2030/08/20/uwsgi + nginx + django部署/</id>
    <published>2030-08-19T16:00:00.000Z</published>
    <updated>2019-12-26T01:59:22.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="uwsgi-nginx-django"><a href="#uwsgi-nginx-django" class="headerlink" title="uwsgi + nginx + django"></a>uwsgi <strong>+</strong> nginx <strong>+</strong> django</h2><a id="more"></a><h4 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a><strong>nginx</strong>配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">user root;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log  /usr/local/nginx/logs/error.log warn;</span><br><span class="line">pid        /run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">    # multi_accept on;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80; # 监听端口</span><br><span class="line">        server_name 47.96.189.157; # 访问路径名称</span><br><span class="line">        charset utf-8; # 编码</span><br><span class="line">        include /usr/local/nginx/conf/mime.types;</span><br><span class="line">        access_log /home/qwe/rening/rening/nginx.log;</span><br><span class="line">        location / &#123;</span><br><span class="line">            include /usr/local/nginx/conf/uwsgi_params;</span><br><span class="line">            uwsgi_connect_timeout 30;</span><br><span class="line">            uwsgi_pass  0.0.0.0:8000; # 反向代理的UWSGI端口</span><br><span class="line">        &#125;</span><br><span class="line">        location /static/ &#123;</span><br><span class="line">            alias /home/qwe/rening/static/; # 项目的静态资源路径,固定写法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="uwsgi配置"><a href="#uwsgi配置" class="headerlink" title="uwsgi配置"></a><strong>uwsgi</strong>配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">#使用nginx连接时使用，Django程序所在服务器地址</span><br><span class="line">socket= 0.0.0.0:8000</span><br><span class="line">#项目目录</span><br><span class="line">chdir=/home/qwe/rening</span><br><span class="line">module=rening.wsgi:application</span><br><span class="line">#项目中wsgi.py文件的目录，相对于项目目录</span><br><span class="line">wsgi-file=rening/wsgi.py</span><br><span class="line"># 进程数</span><br><span class="line">processes=1</span><br><span class="line"># 线程数</span><br><span class="line">threads=2</span><br><span class="line"># uwsgi服务器的角色</span><br><span class="line">master=true</span><br><span class="line">py-autoreload=1</span><br></pre></td></tr></table></figure><h4 id="django文件配置"><a href="#django文件配置" class="headerlink" title="django文件配置"></a><strong>django</strong>文件配置</h4><blockquote><p>子应用文件夹中添加<strong>uwsgi.ini</strong>文件，里面参考<strong>uwsgi配置</strong></p></blockquote><h4 id="启动nginx命令"><a href="#启动nginx命令" class="headerlink" title="启动nginx命令"></a>启动nginx命令</h4><blockquote><p>进入到nginx文件夹, 输入</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx</span><br></pre></td></tr></table></figure><h4 id="启动uwsgi命令"><a href="#启动uwsgi命令" class="headerlink" title="启动uwsgi命令"></a>启动uwsgi命令</h4><blockquote><p>进入项目文件夹, 输入</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uwsgi -d --ini uwsgi.ini</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;uwsgi-nginx-django&quot;&gt;&lt;a href=&quot;#uwsgi-nginx-django&quot; class=&quot;headerlink&quot; title=&quot;uwsgi + nginx + django&quot;&gt;&lt;/a&gt;uwsgi &lt;strong&gt;+&lt;/strong&gt; nginx &lt;strong&gt;+&lt;/strong&gt; django&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
</feed>
